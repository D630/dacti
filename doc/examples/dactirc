#!/usr/bin/env bash

term=x-terminal;
prompt=\>;
DACTI_INDEX_FILE=${XDG_VAR_HOME:?}/lib/dacti/dacti.index;
DACTI_PRETEND=0;

menu=(
    BIN-ASC
    BIN-ATIME-ASC
    BIN-ATIME-DESC
    BIN-DESC
    C-WEB
    CLIPS
    INSERT
    PW
    PW-CLIP
    RADIO
    TASK-ADD
    TASK-LOG
    WEB
    WECKER
    Z
);

function Dacti::CmdMenuCustom
case $in_tty in
    (\?)
        /usr/local/bin/dmenu2 -b -f -i \
            -l "10" \
            -p "$1" \
            -fn "-xos4-terminus-medium-r-normal-*-16-*-*-*-*-*-iso10646-*" \
            -name "dacti" \
            -class "dacti";;
    (*)
        /usr/local/bin/slmenu -b -i -p "$1";;
esac;

function Dacti::CmdMenuEmptyCustom
case $in_tty in
    (\?)
        0<&- /usr/local/bin/dmenu2 -b -f -i \
            -l "10" \
            -p "$1" \
            -fn "-xos4-terminus-medium-r-normal-*-16-*-*-*-*-*-iso10646-*" \
            -name "dacti" \
            -class "dacti";;
    (*)
        <<< "" /usr/local/bin/slmenu -b -i -p "$1";;
esac;

function Dacti::ExecAppCustom () (
    command -v "$command" 1>/dev/null 2>&1 ||
        return 1;

    IFS=' ';

    case ${App[keep]}${App[nterminal]}${App[terminal]} in
        (nt)
            exec $term -e "${SHELL:-sh}" -c "${command[*]}" &;;
        (k)
            exec ${SHELL:-sh} -c "${command[*]};printf 'Press ENTER to continue\n';read";;
        (knt)
            exec $term -e "${SHELL:-sh}" -c "${command[*]};${SHELL:-sh}" &;;
        (t)
            case $in_tty in
                (\?)
                    exec $term -e "${SHELL:-sh}" -c "${command[*]}" &;;
                (*)
                    exec "${command[@]}";;
            esac;;
        (kt)
            case $in_tty in
                (\?)
                    exec $term -e "${SHELL:-sh}" -c "${command[*]};${SHELL:-sh}" &;;
                (*)
                    exec ${SHELL:-sh} -c "${command[*]};printf 'Press ENTER to continue\n';read";;
            esac;;
        ('')
            case $in_tty in
                (\?)
                    exec "${command[@]}" &;;
                (*)
                    if
                        [[ -n ${App[display]} ]];
                    then
                        exec "${command[@]}" &
                    else
                        exec "${command[@]}";
                    fi;;
            esac;;

    esac;
);

function Dacti::ParseSelectionCustom
case ${1,,} in
    (z)
        z-run;;
    (clips)
        clipbuffer;;
    (web)
        case $in_tty in
            (\?)
                setsidw $term -e "${SHELL:-sh}" \
                    -c "furlview ${XDG_VAR_HOME}/log/urls.log;read" 2>/dev/null;;
            (*)
                furlview "${XDG_VAR_HOME}/log/urls.log";;
        esac;;
    (c-web)
        case $in_tty in
            (\?)
                setsidw $term -e "${SHELL:-sh}" \
                    -c "chromium-mselect-history;read" 2>/dev/null;;
            (*)
                chromium-mselect-history;;
        esac;;
    (radio)
        wradio;;
    (pw)
        pass-copy --type;;
    (pw-clip)
        pass-copy;;
    (task-add)
        case $in_tty in
            (\?)
                setsidw $term -e "${SHELL:-sh}" \
                    -c "taskwarrior-add;read" 2>/dev/null;;
            (*)
                taskwarrior-add;;
        esac;;
    (task-log)
        case $in_tty in
            (\?)
                setsidw $term -e "${SHELL:-sh}" \
                    -c "taskwarrior-log;read" 2>/dev/null;;
            (*)
                taskwarrior-log;;
        esac;;
    (wecker)
        case $in_tty in
            (\?)
                setsidw $term -e "${SHELL:-sh}" \
                    -c "rtcwakew;read" 2>/dev/null;;
            (*)
                rtcwakew;;
        esac;;
    (*)
        ! :;;
esac;

if
    [[ $X_XCLIENT == bspwm ]];
then

function Dacti::RaiseAppCustom {
    [[ -n $DISPLAY ]] || {
        Dacti::ExecAppCustom;
        return $?;
    };

    typeset \
        class \
        pid \
        wm_pid \
        xid \
        xlist;

    typeset -a \
        pid_list \
        xids;

    if
        [[ -n ${App[terminal]} ]];
    then
        for pid in $(command pgrep -d ' ' "$command"); do
            until
                [[ ${pid// /} -eq 1 ]];
            do
                pid=$(2>/dev/null command ps -p "${pid// /}" -o ppid=);
                pid_list+=(${pid// /});
            done;
        done;
        read -r _ _ _ _ xlist < <(command xprop -root _NET_CLIENT_LIST);
        for xid in ${xlist//,/}; do
            read -r _ _ wm_pid < <(command xprop -id "$xid" _NET_WM_PID);
            for pid in "${pid_list[@]}"; do
                [[ $wm_pid == $pid ]] &&
                    xids+=($xid);
            done;
        done;
    else
        mapfile -t xids < <(
            command bspc query -N |
            command xargs -I id bspc query -T -n id |
            command jq --arg class "${App[class]}" -r --slurp '
                .[] |
                [.id, .client.instanceName, .client.className] |
                if (@text "\(.[1]).\(.[2])" | test($class))
                then .[0]
                else empty
                end
            ';
        )
    fi;

    case ${#xids[@]} in
        (0)
            Dacti::ExecAppCustom;;
        (1)
            command bspc node "$xids" --activate;
            command bspc node "$xids" --focus;;
        (*)
            for xid in "${xids[@]}"; do
                command bspc node "$xid" --activate;
                command bspc node "$xid" --focus ||
                    return $?;
            done;
    esac;
};

fi;

# vim: set ts=4 sw=4 tw=0 et :
