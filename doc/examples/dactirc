#!/usr/bin/env bash

term=x-terminal;
prompt=\>;
DACTI_INDEX_FILE=${XDG_VAR_HOME:?}/lib/dacti/dacti.index;
DACTI_PRETEND=0;

menu=(
    BIN-ASC
    BIN-ATIME-ASC
    BIN-ATIME-DESC
    BIN-DESC
    C-WEB
    CLIPS
    INSERT
    PW
    PW-CLIP
    RADIO
    TASK-ADD
    TASK-LOG
    WEB
    WECKER
    Z
);

function Dacti::CmdMenuCustom
case $in_tty in
    (\?)
        /usr/local/bin/dmenu2 -b -f -i \
            -l "10" \
            -p "$1" \
            -fn "-xos4-terminus-medium-r-normal-*-16-*-*-*-*-*-iso10646-*" \
            -name "dacti" \
            -class "dacti";;
    (*)
        /usr/local/bin/slmenu -b -i -p "$1";;
esac;

function Dacti::CmdMenuEmptyCustom
case $in_tty in
    (\?)
        0<&- /usr/local/bin/dmenu2 -b -f -i \
            -l "10" \
            -p "$1" \
            -fn "-xos4-terminus-medium-r-normal-*-16-*-*-*-*-*-iso10646-*" \
            -name "dacti" \
            -class "dacti";;
    (*)
        <<< "" /usr/local/bin/slmenu -b -i -p "$1";;
esac;

function Dacti::ExecAppCustom {
    command -v "$command" 1>/dev/null 2>&1 ||
        return 1;

    IFS=' ';

    case ${App[flags]} in
        (nk)
            exec $term -e "${SHELL:-sh}" -c "${command[*]};${SHELL:-sh}" &;;
        (n)
            exec $term -e "${SHELL:-sh}" -c "${command[*]}" &;;
        (k)
            if
                [[ ${App[mode]} == tui && $in_tty == \? ]];
            then
                exec $term -e "${SHELL:-sh}" -c "${command[*]};command printf 'Press ENTER to continue\n';read" &
            else
                exec ${SHELL:-sh} -c "${command[*]};command printf 'Press ENTER to continue\n';read";
            fi;;
        ('')
            case $in_tty in
                (\?)
                    if
                        [[ ${App[mode]} == tui ]];
                    then
                        exec $term -e "${SHELL:-sh}" -c "${command[*]}" &
                    else
                        exec "${command[@]}" &
                    fi;;
                (*)
                    exec "${command[@]}";;
            esac;;
    esac;
};

function Dacti::ParseSelectionCustom {
    typeset selection="$@";

    case ${selection,,} in
        (z)
            exec z-run;;
        (clips)
            exec clipbuffer;;
        (web)
            case $in_tty in
                (\?)
                    exec setsidw ${term} -e "${SHELL:-sh}" \
                        -c "furlview ${XDG_VAR_HOME}/log/urls.log;read" 2>/dev/null;;
                (*)
                    exec furlview "${XDG_VAR_HOME}/log/urls.log" 2>/dev/null;;
            esac;;
        (c-web)
            case $in_tty in
                (\?)
                    exec setsidw ${term} -e "${SHELL:-sh}" \
                        -c "chromium-mselect-history;read" 2>/dev/null;;
                (*)
                    exec chromium-mselect-history 2>/dev/null;;
            esac;;
        (radio)
            exec wradio;;
        (pw)
            exec pass-copy --type;;
        (pw-clip)
            exec pass-copy;;
        (task-add)
            case $in_tty in
                (\?)
                    exec setsidw ${term} -e "${SHELL:-sh}" \
                        -c "taskwarrior-add;read" 2>/dev/null;;
                (*)
                    exec taskwarrior-add;;
            esac;;
        (task-log)
            case $in_tty in
                (\?)
                    exec setsidw ${term} -e "${SHELL:-sh}" \
                        -c "taskwarrior-log;read" 2>/dev/null;;
                (*)
                    exec taskwarrior-log;;
            esac;;
        (wecker)
            case $in_tty in
                (\?)
                    exec setsidw ${term} -e "${SHELL:-sh}" \
                        -c "rtcwakew;read" 2>/dev/null;;
                (*)
                    rtcwakew;;
            esac;;
        (*)
            return 1;
    esac;
};

function Dacti::RaiseAppCustom {
    typeset \
        class \
        id \
        pid \
        wm_pid \
        xlist;

    typeset -a \
        pid_list \
        xids;

    read -r _ _ _ _ xlist < <(command xprop -root _NET_CLIENT_LIST);

    if
        [[ ${App[mode]} == gui ]];
    then
        for id in ${xlist//,/}; do
            read -r _ _ class < <(command xprop -id "$id" WM_CLASS);
            class=${class//\"/};
            [[ ${class/, /.} =~ ${App[class]} ]] &&
                xids+=($id);
        done;
    else
        for pid in $(command pgrep -d ' ' "$command"); do
            until
                [[ ${pid// /} -eq 0 ]];
            do
                pid=$(2>/dev/null command ps -p "${pid// /}" -o ppid=);
                pid_list+=(${pid// /});
            done;
        done;
        for id in ${xlist//,/}; do
            read -r _ _ wm_pid < <(command xprop -id "$id" _NET_WM_PID);
            for pid in "${pid_list[@]}"; do
                [[ $wm_pid == $pid ]] &&
                    xids+=($id);
            done;
        done;
    fi;

    case ${#xids[@]} in
        (0)
            Dacti::ExecApp;;
        (1)
            command wmctrl -i -a "$xids";;
        (*)
            for id in "${xids[@]}"; do
                command wmctrl -i -a "$id" ||
                    return $?;
            done;
    esac;
};

# vim: set ts=4 sw=4 tw=0 et :
