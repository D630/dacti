#!/usr/bin/env bash
#
# Copyright 2014 -- 2017 D630
# https://github.com/D630/dacti

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o errexit
#set -o errtrace
#set -o noexec
#set -o nounset
#set -o pipefail
#set -o verbose
#set -o xtrace
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG
#exec 2>> ~/dacti.log
#typeset vars_base=$(set -o posix ; set)
#fgrep -v -e "$vars_base" < <(set -o posix ; set) | \
#egrep -v -e "^BASH_REMATCH=" \
#         -e "^OPTIND=" \
#         -e "^REPLY=" \
#         -e "^BASH_LINENO=" \
#         -e "^BASH_SOURCE=" \
#         -e "^FUNCNAME=" | \
#less

[[ ${BASH_SOURCE[0]} == $0 ]] || {
    printf 'Error: Do not execute dacti via source\n' 1>&2;
    return 1 2>/dev/null;
};

# -- FUNCTIONS.

function Dacti::CmdMenu
if
    typeset -F Dacti::CmdMenuCustom 1>/dev/null 2>&1;
then
    Dacti::CmdMenuCustom "${1:-$prompt}";
else
    command dmenu -p "${1:-$prompt}";
fi;

function Dacti::CmdMenuEmpty
if
    typeset -F Dacti::CmdMenuEmptyCustom 1>/dev/null 2>&1;
then
    Dacti::CmdMenuEmptyCustom "${1:-$prompt}";
else
    command dmenu -p "${1:-$prompt}" 0<&-;
fi;

function Dacti::ExecApp {
    if
        typeset -F Dacti::ExecAppCustom 1>/dev/null 2>&1;
    then
        Dacti::ExecAppCustom;
    else
        (
        command -v "$command" 1>/dev/null 2>&1 ||
            return 1;
        IFS=' ';
        case ${App[keep]}${App[nterminal]}${App[terminal]} in
            (nt)
                exec $term -e "${SHELL:-sh}" -c "${command[*]}" &;;
            (k)
                exec ${SHELL:-sh} -c "${command[*]};printf 'Press ENTER to continue\n';read";;
            (knt)
                exec $term -e "${SHELL:-sh}" -c "${command[*]};${SHELL:-sh}" &;;
            (t)
                case $in_tty in
                    (\?)
                        exec $term -e "${SHELL:-sh}" -c "${command[*]}" &;;
                    (*)
                        exec "${command[@]}";;
                esac;;
            (kt)
                case $in_tty in
                    (\?)
                        exec $term -e "${SHELL:-sh}" -c "${command[*]};${SHELL:-sh}" &;;
                    (*)
                        exec ${SHELL:-sh} -c "${command[*]};printf 'Press ENTER to continue\n';read";;
                esac;;
            ('')
                case $in_tty in
                    (\?)
                        exec "${command[@]}" &;;
                    (*)
                        if
                            [[ -n ${App[display]} ]];
                        then
                            exec "${command[@]}" &
                        else
                            exec "${command[@]}";
                        fi;;
                esac;;
        esac;
        )
    fi;
};

function Dacti::Main {
    case $1 in
        (-h|--help)
            Dacti::PrintHelp;
            exit 0;;
    esac;

    typeset \
        prompt=\> \
        selection \
        term=xterm;

    typeset -i DACTI_PRETEND=$DACTI_PRETEND;

    typeset \
        DACTI_CONF_FILE=${DACTI_CONF_FILE:-${XDG_CONFIG_HOME:-$HOME/.config}/dacti/dactirc} \
        DACTI_INDEX_FILE=${DACTI_INDEX_FILE:-${XDG_DATA_HOME:-$HOME/.local/share}/dacti/dacti.index};

    typeset -a menu=(
        BIN-ASC
        BIN-ATIME-ASC
        BIN-ATIME-DESC
        BIN-DESC
        INSERT
    ) apps;

    typeset -r in_tty=$(command ps -p "$PPID" -o tty=);

    if
        [[ -e $DACTI_CONF_FILE ]];
    then
        . "$DACTI_CONF_FILE";
    else
        command mkdir -p "${DACTI_CONF_FILE%/*}";
    fi;

    unset -v DactiApps;
    typeset -A DactiApps;

    if
        [[ -e $DACTI_INDEX_FILE ]]
    then
        function reg {
            DactiApps+=(
                [app $3]=${3:?}
                [status $3]=reg
                [class $3]=${2:?}
                [flags $3]=${1:?}
            );
            apps+=("$3");
        };
        function ign {
            DactiApps+=(
                [app $3]=${3:?}
                [status $3]=ign
                [class $3]=${2:?}
                [flags $3]=${1:?}
            );
            apps+=("$3");
        };
        . "$DACTI_INDEX_FILE";
    else
        command mkdir -p "${DACTI_INDEX_FILE%/*}";
        > "$DACTI_INDEX_FILE";
    fi;

    while
        :;
    do
        selection=$(
            Dacti::PrintMenu0 |
            sort -u |
            Dacti::CmdMenu;
        );
        case ${selection,,} in
            (\[bin-asc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinAsc |
                    Dacti::CmdMenu BIN-ASC;
                )";;
            (\[bin-atime-asc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinAtimeAsc |
                    Dacti::CmdMenu BIN-ATIME-ASC;
                )";;
            (\[bin-atime-desc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinAtimeDesc |
                    Dacti::CmdMenu BIN-ATIME-DESC;
                )";;
            (\[bin-desc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinDesc |
                    Dacti::CmdMenu BIN-DESC;
                )";;
            (\[insert\])
                Dacti::ParseSelection "$(Dacti::CmdMenuEmpty)";;
            (\[*\])
                typeset -F Dacti::ParseSelectionCustom 1>/dev/null 2>&1 &&
                    Dacti::ParseSelectionCustom "${selection//[\[\]]/}";;
            ('')
                :;;
            (*)
                Dacti::ParseSelection "$selection";;
        esac;
        (($?)) ||
            return 0;
    done;
};

function Dacti::ParseSelection {
    [[ -n $* ]] ||
        return 1;

    typeset pref_class;

    typeset -i \
        pref_idx=1 \
        pref_pretend=$DACTI_PRETEND \
        s=;

    typeset -a command=($@);

    typeset -A App=(
        [flags]=
        [keep]=
        [display]=
        [nterminal]=
        [terminal]=
        [status]=reg
    );

    if
        [[ $command == :* ]];
    then
        ((${#command[@]} > 1)) || {
            printf 'Error: Command missing\n' 1>&2;
            return 1;
        };
        while
            read -r -n 1;
        do
            case $REPLY in
                (k)
                    App[keep]=k;;
                (d)
                    App[display]=d;;
                (i)
                    App[status]=ign;;
                (n)
                    App[terminal]=t;
                    App[nterminal]=n;;
                (p)
                    pref_pretend=1;;
                (t)
                    App[terminal]=t;;
            esac;
        done <<< "${command#:}";
        command=(${command[@]:1});
    else
        if
            [[ -v "DactiApps[app $command]" ]];
        then
            pref_idx=0;
            while
                read -r -n 1;
            do
                case $REPLY in
                    (k)
                        App[keep]=k;;
                    (n)
                        App[nterminal]=n;;
                    (d)
                        App[display]=d;;
                    (t)
                        App[terminal]=t;;
                esac;
            done <<< "${DactiApps[flags $command]}";
            App[status]=${DactiApps[status $command]};
            pref_class=${DactiApps[class $command]};
        fi;
    fi;

    [[ -z $DISPLAY && -n ${App[display]} ]] && {
        printf 'Error: App depends on DISPLAY\n' 1>&2;
        return 1;
    };

    App[flags]=${App[display]}${App[keep]}${App[nterminal]}${App[terminal]};
    App[flags]=${App[flags]:--};

    if
        [[ -n $pref_class ]];
    then
        App[class]=$pref_class;
    elif
        [[ -z ${App[display]} ]];
    then
        App[class]=-;
    else
        typeset c=${command[0]:0:1};
        App[class]=${command[0]}.${c^}${command[0]:1};
    fi;

    typeset -r \
        App \
        command \
        pref_idx \
        pref_pretend;

    case ${App[status]} in
        (ign)
            Dacti::ExecApp;;
        (reg)
            Dacti::RaiseApp;;
        (*)
            exit 1;;
    esac;

    s=$?;

    [[ $pref_idx$pref_pretend$s -eq 100 ]] &&
        printf %s\\n \
            "${App[status]} ${App[flags]} ${App[class]} $command" \
            >> "$DACTI_INDEX_FILE";

    return $s;
};

function Dacti::PrintHelp {
    { typeset help=$(</dev/fd/0); } <<'HELP'
Usage
    dacti [ -h | --help ]

Main selection menu: entries
    BIN-ASC                         Browse executables within PATH. Sort
                                    them in ascending order by their names.
    BIN-DESC                        "" Sort them in descending order by their
                                    names.
    BIN-ATIME-ASC                   "" Sort them in ascending order by their
                                    access times.
    BIN-ATIME-DESC                  "" Sort them in descending order by their
                                    access times.
    INSERT                          Open a menu with an empty list and insert
                                    a command.
    [:MODIFIERS ]COMMAND            Launch application (run or raise) from
                                    DACTI_INDEX_FILE.

Main selecton menu: modifiers
    i                               Declare status 'ign'.
    k                               Keep the process. Wait for a key press
                                    or spawn a new shell instance.
    d                               COMMAND depends on DISPLAY.
    n                               Run COMMAND in a new terminal emulator
                                    window.
    p                               Launch COMMAND directly and create NO
                                    record.
                                    See also env variable DACTI_PRETEND.
    t                               COMMAND needs a controlling tty.

Environment variables
    DACTI_CONF_FILE                 See function Dacti::Main
    DACTI_INDEX_FILE                ""
    DACTI_PRETEND                   Default: 0

Configuration
    normal scalar variables
        in_tty                      Output of: ps -p "$PPID" -o tty=
        prompt                      Default: >
        term                        Default: xterm
    indexed array variables
        apps                        All app names from DACTI_INDEX_FILE.
        command                     Selected/Typed command list without prefixed
                                    modifiers.
        menu                        See entry section above.
    associative array variables
        App                         Parsed preferences for COMMAND:
                                    <class>
                                    <display>
                                    <flags>
                                    <keep>
                                    <nterminal>
                                    <status>
                                    <terminal>
        DactiApps                   Mapped entries from DACTI_INDEX_FILE:
                                    <app COMMAND>
                                    <class COMMAND>
                                    <flags COMMAND>
                                    <status COMMAND>
    functions
        Dacti::CmdMenuCustom        See doc/examples/dactirc
        Dacti::CmdMenuEmptyCustom   ""
        Dacti::ExecAppCustom        ""
        Dacti::ParseSelectionCustom ""
        Dacti::RaiseAppCustom       ""
HELP

    printf '%s\n' "$help";
};

function Dacti::PrintMenu0 {
    printf '[%s]\n' "${menu[@]}";
    printf '%s\n' "${apps[@]}";
};

function Dacti::PrintMenuBinAsc {
    command stest -flx ${PATH//:/ } |
    command sort -u;
};

function Dacti::PrintMenuBinAtimeAsc {
    command find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' |
    command sort -n |
    command cut -f2 |
    command grep -F -xf <(command stest -flx ${PATH//:/ }) |
    command uniq;
};

function Dacti::PrintMenuBinAtimeDesc {
    command find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' |
    command sort -rn |
    command cut -f2 |
    command grep -F -xf <(command stest -flx ${PATH//:/ }) |
    command uniq;
};

function Dacti::PrintMenuBinDesc {
    command stest -flx ${PATH//:/ } |
    command sort -ru;
};

function Dacti::RaiseApp
if
    typeset -F Dacti::RaiseAppCustom 1>/dev/null 2>&1;
then
    Dacti::RaiseAppCustom;
else
    [[ -n $DISPLAY ]] || {
        Dacti::ExecApp;
        return $?;
    };
    typeset \
        class \
        pid \
        wm_pid \
        xid \
        xlist;
    typeset -a \
        pid_list \
        xids;
    read -r _ _ _ _ xlist < <(command xprop -root _NET_CLIENT_LIST);
    if
        [[ -n ${App[terminal]} ]];
    then
        for pid in $(command pgrep -d ' ' "$command"); do
            until
                [[ ${pid// /} -eq 1 ]];
            do
                pid=$(2>/dev/null command ps -p "${pid// /}" -o ppid=);
                pid_list+=(${pid// /});
            done;
        done;
        for xid in ${xlist//,/}; do
            read -r _ _ wm_pid < <(command xprop -id "$xid" _NET_WM_PID);
            for pid in "${pid_list[@]}"; do
                [[ $wm_pid == $pid ]] &&
                    xids+=($xid);
            done;
        done;
    else
        for xid in ${xlist//,/}; do
            # eval "$(xprop -id "$xid" -notype -f WM_CLASS 8u =\(\$0+\\\)\\n WM_CLASS)";
            # [[ ${WM_CLASS%,}.${WM_CLASS[1]} =~ ${App[class]} ]] &&
            #     xids+=($xid);
            read -r _ _ class < <(command xprop -id "$xid" WM_CLASS);
            class=${class//\"/};
            [[ ${class/, /.} =~ ${App[class]} ]] &&
                xids+=($xid);
        done;
    fi;
    case ${#xids[@]} in
        (0)
            Dacti::ExecApp;;
        (1)
            command wmctrl -i -a "$xids";;
        (*)
            for xid in "${xids[@]}"; do
                command wmctrl -i -a "$id" ||
                    return $?;
            done;
    esac;
fi;

# -- MAIN.

Dacti::Main "$@";

# vim: set ts=4 sw=4 tw=0 et :
