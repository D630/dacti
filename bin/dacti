#!/usr/bin/env bash

# Copyright 2014 -- 2017 D630
# https://github.com/D630/dacti

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o errexit
#set -o errtrace
#set -o noexec
#set -o nounset
#set -o pipefail
#set -o verbose
#set -o xtrace
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG
#exec 2>> ~/dacti.log
#typeset vars_base=$(set -o posix ; set)
#fgrep -v -e "$vars_base" < <(set -o posix ; set) | \
#egrep -v -e "^BASH_REMATCH=" \
#         -e "^OPTIND=" \
#         -e "^REPLY=" \
#         -e "^BASH_LINENO=" \
#         -e "^BASH_SOURCE=" \
#         -e "^FUNCNAME=" | \
#less

[[ ${BASH_SOURCE[0]} == $0 ]] || {
    printf 'Error: Do not execute dacti via source\n' 1>&2;
    return 1 2>/dev/null;
};

# -- FUNCTIONS.

function Dacti::CmdMenu
if
    typeset -F Dacti::CmdMenuCustom 1>/dev/null 2>&1;
then
    Dacti::CmdMenuCustom "${1:-$prompt}";
else
    command dmenu -p "${1:-$prompt}";
fi;

function Dacti::CmdMenuEmpty
if
    typeset -F Dacti::CmdMenuEmptyCustom 1>/dev/null 2>&1;
then
    Dacti::CmdMenuEmptyCustom "${1:-$prompt}";
else
    command dmenu -p "${1:-$prompt}" 0<&-;
fi;

function Dacti::ExecApp () (
    if
        typeset -F Dacti::ExecAppCustom 1>/dev/null 2>&1;
    then
        Dacti::ExecAppCustom;
    else
        command -v "$command" 1>/dev/null 2>&1 ||
            return 1;
        IFS=' ';
        case ${App[flags]} in
            (nk)
                exec $term -e "${SHELL:-sh}" -c "${command[*]};${SHELL:-sh}" &;;
            (n)
                exec $term -e "${SHELL:-sh}" -c "${command[*]}" &;;
            (k)
                if
                    [[ ${App[mode]} == tui && $in_tty == \? ]];
                then
                    exec $term -e "${SHELL:-sh}" -c "${command[*]};command printf 'Press ENTER to continue\n';read" &
                else
                    exec ${SHELL:-sh} -c "${command[*]};command printf 'Press ENTER to continue\n';read";
                fi;;
            ('')
                case $in_tty in
                    (\?)
                        if
                            [[ ${App[mode]} == tui ]];
                        then
                            exec $term -e "${SHELL:-sh}" -c "${command[*]}" &
                        else
                            exec "${command[@]}" &
                        fi;;
                    (*)
                        exec "${command[@]}";;
                esac;;
        esac;
    fi;
);

function Dacti::Main {
    case $1 in
        (-h|--help)
            Dacti::PrintHelp;
            exit 0;;
        (-v|--version)
            Dacti::PrintVersion;
            exit 0;;
    esac;

    typeset \
        predir_confdir=${XDG_CONFIG_HOME:-$HOME/.config} \
        predir_datadir=${XDG_DATA_HOME:-$HOME/.local/share} \
        prompt=\> \
        selection \
        term=xterm;

    typeset -i DACTI_PRETEND=$DACTI_PRETEND;

    typeset \
        DACTI_CONF_FILE=${DACTI_CONF_FILE:-$predir_confdir/dacti/dactirc} \
        DACTI_INDEX_FILE=${DACTI_INDEX_FILE:-$predir_datadir/dacti/dacti.index};

    typeset -a menu=(
        BIN-ASC
        BIN-ATIME-ASC
        BIN-ATIME-DESC
        BIN-DESC
        INSERT
    ) apps;

    typeset -r \
        DACTI_CONF_FILE \
        in_tty=$(command ps -p "$PPID" -o tty=);

    if
        [[ -e $DACTI_CONF_FILE ]];
    then
        . "$DACTI_CONF_FILE";
    else
        command mkdir -p "${DACTI_CONF_FILE%/*}";
    fi;

    unset -v DactiApps;
    typeset -A DactiApps;

    if
        [[ -e $DACTI_INDEX_FILE ]]
    then
        function block { false; };
        function reg {
            DactiApps+=(
                [app $3]=$3
                [status $3]=reg
                [mode $3]=${1%%:*}
                [class $3]=$2
                [flags $3]=${1##*:}
            );
            apps+=("$3");
        };
        function ign {
            DactiApps+=(
                [app $3]=$3
                [status $3]=ign
                [mode $3]=${1%%:*}
                [class $3]=$2
                [flags $3]=${1##*:}
            );
            apps+=("$3");
        };
        . "$DACTI_INDEX_FILE";
    else
        command mkdir -p "${DACTI_INDEX_FILE%/*}";
        > "$DACTI_INDEX_FILE";
    fi;

    while
        :;
    do
        selection=$(
            Dacti::PrintMenu0 |
            sort |
            Dacti::CmdMenu;
        );
        case ${selection,,} in
            (\[bin-asc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinAsc |
                    Dacti::CmdMenu BIN-ASC;
                )";;
            (\[bin-atime-asc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinAtimeAsc |
                    Dacti::CmdMenu BIN-ATIME-ASC;
                )";;
            (\[bin-atime-desc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinAtimeDesc |
                    Dacti::CmdMenu BIN-ATIME-DESC;
                )";;
            (\[bin-desc\])
                Dacti::ParseSelection "$(
                    Dacti::PrintMenuBinDesc |
                    Dacti::CmdMenu BIN-DESC;
                )";;
            (\[insert\])
                Dacti::ParseSelection "$(Dacti::CmdMenuEmpty)";;
            (\[*\])
                typeset -F Dacti::ParseSelectionCustom 1>/dev/null 2>&1 &&
                    Dacti::ParseSelectionCustom "${selection//[\[\]]/}";;
            ('')
                :;;
            (*)
                Dacti::ParseSelection "$selection";;
        esac;
        (($?)) ||
            return 0;
    done;
};

function Dacti::ParseSelection {
    [[ -n $* ]] ||
        return 1;

    typeset \
        pref_opts \
        pref_status \
        pref_mode;

    typeset -i \
        pref_idx= \
        pref_keep= \
        pref_nterminal= \
        pref_pretend=$DACTI_PRETEND \
        s= ;

    typeset -a command=($1);

    typeset -A App;

    [[ $command == :* ]] && {
        while
            read -r -n 1;
        do
            case $REPLY in
                (k)
                    pref_keep=1;;
                (c)
                    pref_mode=cli;;
                (i)
                    pref_status=ign;;
                (n)
                    pref_nterminal=1;;
                (p)
                    pref_pretend=1;;
                (t)
                    pref_mode=tui;;
                (u)
                    pref_idx=1;;
            esac;
        done <<< "${command#:}";

        command=(${command[@]:1});
    };

    if
        ((pref_pretend + pref_idx == 0));
    then
        if
            [[ -v "DactiApps[app $command]" ]];
        then
            while
                read -r -n 1;
            do
                case $REPLY in
                    (k)
                        pref_keep=1;;
                    (n)
                        pref_nterminal=1;;
                esac;
            done <<< "${DactiApps[flags $command]}";
        fi;
        [[ -n ${DactiApps[status $command]} ]] ||
            pref_idx=1;
    fi;

    ((pref_keep)) &&
        pref_opts=k;
    ((pref_nterminal)) &&
        pref_opts+=n;

    App[status]=${pref_status:-${DactiApps[status $command]}};
    App[status]=${App[status]:-reg};
    App[flags]=$pref_opts
    App[mode]=${pref_mode:-${DactiApps[mode $command]}};
    App[mode]=${App[mode]:-gui};

    if
        [[ -n ${DactiApps[class $command]} ]];
    then
        App[class]=${DactiApps[class $command]};
    elif
        [[ ${App[mode]} != gui ]];
    then
        App[class]=-;
    else
        typeset c=${command[0]:0:1};
        App[class]=${command[0]}.${c^}${command[0]:1};
    fi;

    typeset -r \
        App \
        command \
        pref_idx \
        pref_pretend;

    case ${App[status]} in
        (block)
            ! :;;
        (ign)
            Dacti::ExecApp;;
        (reg)
            Dacti::RaiseApp;;
        (*)
            exit 1;;
    esac;

    s=$?;

    [[ $pref_idx$pref_pretend$s -eq 100 ]] &&
        printf %s\\n \
            "${App[status]} ${App[mode]}${App[flags]} ${App[class]} $command" \
            >> "$DACTI_INDEX_FILE";

    return $s;
};

function Dacti::PrintHelp {
    { typeset help=$(</dev/fd/0); } <<'HELP'
Usage
    dacti [ -h | --help | -v | --version ]

Main selection menu: entries
    [BIN-ASC]                       Browse executables within PATH. Sort
                                    them in ascending order by their names.
    [BIN-DESC]                      "" Sort them in descending order by their
                                    names.
    [BIN-ATIME-ASC]                 "" Sort them in ascending order by their
                                    access times.
    [BIN-ATIME-DESC]                "" Sort them in descending order by their
                                    access times.
    [INSERT]                        Open a menu with an empty list and insert
                                    a command.
    <COMMAND>                       Launch application (run or raise).

Main selecton menu: modifiers
    :c                              Declare mode 'cli'.
    :i                              Declare status 'ign'.
    :k                              Keep the process. Wait for a key press
                                    or spawn a new shell instance.
    :n                              Run COMMAND in a new terminal emulator
                                    window.
    :p                              Don't check, whether COMMAND is indexed.
                                    Launch it directly and create NO record.
                                    See also env variable DACTI_PRETEND.
    :t                              Declare mode 'tui'.
    :u                              Don't check, whether COMMAND is indexed.
                                    Launch it directly and create a new
                                    record.

Environment variables
    DACTI_CONF_FILE                 See function Dacti::Main
    DACTI_INDEX_FILE                ""
    DACTI_PRETEND                   Default: 0

Configuration
    normal scalar variables
        in_tty                      Output of: ps -p "$PPID" -o tty=
        prompt                      Default: >
        term                        Default: xterm
    indexed array variables
        apps                        All app names from DACTI_INDEX_FILE.
        command                     Selected/Typed command list without prefixed
                                    modifiers.
        menu                        See entry section above. Default:
                                    BIN-ASC
                                    BIN-ATIME-ASC
                                    BIN-ATIME-DESC
                                    BIN-DESC
                                    INSERT
    associative array variables
        App                         Parsed preferences for COMMAND:
                                    <status>
                                    <mode>
                                    <flags>
                                    <class>
        DactiApps                   Mapped entries from DACTI_INDEX_FILE:
                                    <status COMMAND>
                                    <mode COMMAND>
                                    <FLAGS COMMAND>
                                    <class COMMAND>
                                    <app COMMAND>
    functions
        Dacti::CmdMenuCustom        See doc/examples/dactirc
        Dacti::CmdMenuEmptyCustom   ""
        Dacti::ExecAppCustom        ""
        Dacti::ParseSelectionCustom ""
        Dacti::RaiseAppCustom       ""
HELP

    printf '%s\n' "$help";
};

function Dacti::PrintMenu0 {
    printf '[%s]\n' "${menu[@]}";
    printf '%s\n' "${apps[@]}";
};

function Dacti::PrintMenuBinAsc {
    command stest -flx ${PATH//:/ } |
    command sort -u;
};

function Dacti::PrintMenuBinAtimeAsc {
    command find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' |
    command sort -n |
    command cut -f2 |
    command grep -F -xf <(command stest -flx ${PATH//:/ }) |
    command uniq;
};

function Dacti::PrintMenuBinAtimeDesc {
    command find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' |
    command sort -rn |
    command cut -f2 |
    command grep -F -xf <(command stest -flx ${PATH//:/ }) |
    command uniq;
};

function Dacti::PrintMenuBinDesc {
    command stest -flx ${PATH//:/ } |
    command sort -ru;
};

function Dacti::PrintVersion {
    printf %s\\n 0.2.7;
};

function Dacti::RaiseApp
if
    typeset -F Dacti::RaiseAppCustom 1>/dev/null 2>&1;
then
    Dacti::RaiseAppCustom;
else
    typeset \
        class \
        id \
        pid \
        wm_pid \
        xlist;

    typeset -a \
        pid_list \
        xids;

    read -r _ _ _ _ xlist < <(command xprop -root _NET_CLIENT_LIST);

    if
        [[ ${App[mode]} == gui ]];
    then
        for id in ${xlist//,/}; do
            read -r _ _ class < <(command xprop -id "$id" WM_CLASS);
            class=${class//\"/};
            [[ ${class/, /.} =~ ${App[class]} ]] &&
                xids+=($id);
        done;
    else
        for pid in $(command pgrep -d ' ' "$command"); do
            until
                [[ ${pid// /} -eq 0 ]];
            do
                pid=$(2>/dev/null command ps -p "${pid// /}" -o ppid=);
                pid_list+=(${pid// /});
            done;
        done;
        for id in ${xlist//,/}; do
            read -r _ _ wm_pid < <(command xprop -id "$id" _NET_WM_PID);
            for pid in "${pid_list[@]}"; do
                [[ $wm_pid == $pid ]] &&
                    xids+=($id);
            done;
        done;
    fi;

    case ${#xids[@]} in
        (0)
            Dacti::ExecApp;;
        (1)
            command wmctrl -i -a "$xids";;
        (*)
            for id in "${xids[@]}"; do
                command wmctrl -i -a "$id" ||
                    return $?;
            done;
    esac;
fi;

# -- MAIN.

Dacti::Main "$@";

# vim: set ts=4 sw=4 tw=0 et :
