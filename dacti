#!/usr/bin/env bash

# Copyright 2014 D630
# https://github.com/D630/dacti

# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General
# Public License along with this program. If not, see
# <http://www.gnu.org/licenses/gpl-3.0.html>.

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace #; exec 2>> ~/dacti.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__dacti_version() { echo "0.0.9.15" ; }

__dacti_bin_asc() { lsx ${PATH//:/ } | sort | uniq ; }

__dacti_bin_atime_asc() { find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' | sort -n | cut -f2 | fgrep -xf <(lsx ${PATH//:/ }) | uniq  ; }

__dacti_bin_atime_desc() { find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' | sort -rn | cut -f2 | fgrep -xf <(lsx ${PATH//:/ }) | uniq ; }

__dacti_bin_desc() { lsx ${PATH//:/ } | sort -r | uniq ; }

__dacti_menu() { ${menu_cmd} -p "${1:->}" $d_opt $d_screen $d_name $d_class $d_h $d_w $d_x $d_y $d_o $d_dim $d_dc ${d_color[*]} $d_fn ; }

__dacti_occur() { grep -e '^.* launch .*$' "$DACTI_LOG_FILE" | cut -d ' ' -f3 | sort | uniq -c | sort -nr ; }

__dacti_browse_log() { sort -rn "$DACTI_LOG_FILE" ; }

__dacti_browse_categories()
{
    (($# == 0)) && return 1

    declare \
            selection=$1 \
            parent=

    [[ $selection =~ ^:.*u.*[[:space:]].*$ ]] &&
    {
        __dacti_update_categories && __dacti_logger "Categories: Update has been processed."
        selection=${selection#:* }
    }

    read -r selection < <(find "$DACTI_CATS_DATA_DIR" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' | sort | __dacti_menu "CATEGORIES")
    parent=${DACTI_CATS_DATA_DIR##*/}/${selection}
    while [[ $selection ]]
    do
        read -r selection < <({ printf '%s\n' '[..]' '[.]' ; find "${DACTI_CATS_DATA_DIR%/*}/${parent}" -mindepth 1 -maxdepth 1 -printf '%f\n' ; } | sort | __dacti_menu ${parent##*/})
        case $selection in
            \[..\])     parent=${parent%/*}                           ;;
            \[.\])      parent=$parent                                ;;
            *.desktop)  __dacti_check_status "${selection%.desktop}"  ;;
            *)          parent=${parent}/${selection}                 ;;
        esac
    done
}

__dacti_browse_keywords()
{
    __dacti_search_post()
    {
        declare key=

        if [[ ( ${operators[or]} && ${operators[not]} ) || ${operators[or]} ]]
        then
            for key in "${!search[@]}"
            do
                [[ $key =~ (^not*|^and*) ]] && continue
                [[ ${search[$key]} == ${search[${key/or/not}]} ]] &&
                {
                    unset -v "search[$key]"
                    unset -v "search[${key/or/not}]"
                }
            done
            [[ ${operators[and]} ]] &&
            {
                for key in "${!search[@]}"
                do
                    [[ $key =~ ^and* ]] && continue
                    if [[ ${search[$key]} == ${search[${key/or/and}]} ]]
                    then
                        unset -v "search[${key/or/and}]"
                    else
                        unset -v "search[$key]"
                    fi
                done
            }
            for key in "${!search[@]}"
            do
                [[ ! $key =~ ^and* ]] && search[${key/or /}]=1
                unset -v "search[$key]"
            done
        elif [[ ${operators[not]} ]]
        then
            for key in "${!search[@]}"
            do
                [[ $key =~ ^not* ]] &&
                {
                    keyy=${key/not /}
                    search[${keyy% *}]=1
                }
                unset -v "search[$key]"
            done
            for key in "${!search[@]}"
            do
                [[ $key =~ [[:blank:]] ]] || unset -v "search[$key]"
            done
        fi
    }

    (($# == 0)) && return 1

    declare \
            file= \
            i= \
            keywords= \
            operator= \
            parent= \
            query= \
            query_keywords= \
            selection=$1

    declare -A search \
               operators

    [[ $selection == :* ]] &&
    {
        [[ $selection =~ ^:.*u.*[[:space:]].*$ ]] && __dacti_update_keywords && __dacti_logger "Keywords: Update has been proccessed."
        [[ $selection =~ ^:.*q.*[[:space:]].*$ ]] && query_keywords=query_keywords
        selection=${selection#:* }
    }

    if [[ $query_keywords ]]
    then
        selection=
        eval query=($(__dacti_menu "QUERY" <<< ""))
        for i in "${query[@]}"
        do
            [[ $i =~ ^(and|not|or)$ ]] && operator=$i && continue
            operator=${operator:-or}
            operators[$operator]=1
            while IFS=':' read -r file keywords
            do
                keywords=${keywords#Keywords=}
                search[${operator} ${file}]=1
            done < <(egrep -e "^(.*):Keywords=.*${i};.*$" "$DACTI_KEYWS_INDEX_FILE")
        done
        __dacti_search_post
        selection=$(for key in "${!search[@]}" ; do printf '%s\n' "${key##*/}" ; done | __dacti_menu "MATCH")
        [[ $selection ]] && __dacti_check_status "${selection%.desktop}"
    else
        read -r selection < <(__dacti_menu "KEYWORDS" < "$DACTI_KEYWS_CACHE_FILE")
        while [[ $selection ]]
        do
            parent=$selection
            read -r selection < <({ printf '%s\n' '[..]' '[.]' ; while IFS=':' read -r file keywords ; do printf '%s\n' "${file##*/}" ; done < <(egrep -e "^(.*):Keywords=.*${selection};.*$" "$DACTI_KEYWS_INDEX_FILE") ; }| __dacti_menu "$parent")
            case $selection in
                \[.\])      selection=$parent                                                           ;;
                \[..\])     read -r selection < <(__dacti_menu "KEYWORDS" < "$DACTI_KEYWS_CACHE_FILE") ;;
                *)          __dacti_check_status "${selection%.desktop}"                                ;;
            esac
        done
    fi
}

__dacti_check_status()
{
    __dacti_check_wins()
    {
        declare \
                i= \
                id= \
                net_client_list= \
                net_wm_pid= \
                pid=

        declare -g startup_wmclass=

        declare -a \
                   pid_list=() \
                   xids=()

        read -r _ _ _ _ net_client_list < <(xprop -root _NET_CLIENT_LIST)

        if [[ ${sections[${section_number} X_dacti_mode]} != gui ]]
        then
            for pid in $(pgrep -d ' ' "${selection% *}")
            do
                until [[ ${pid// /} == 0 ]]
                do
                    pid=$(ps -p "${pid// /}" -o ppid= 2>/dev/null)
                    pid_list+=(${pid// /})
                done
            done
            for id in ${net_client_list//,/}
            do
                read -r _ _ net_wm_pid < <(xprop -id "$id" _NET_WM_PID)
                for pid in "${pid_list[@]}"
                do
                    [[ $net_wm_pid == $pid ]] && xids+=($id)
                done
            done
        else
            for id in ${net_client_list//,/}
            do
                [[ $(xprop -id "$id" WM_CLASS) =~ ${sections[${section_number} StartupWMClass]:-${selection% *}} ]] &&
                xids+=($id) &&
                startup_wmclass=${BASH_REMATCH[0]}
            done
        fi

        case ${#xids[@]} in
            0)
                    __dacti_exec_selection
                    ;;
            1)
                    if [[ ${sections[${section_number} X_dacti_win_sg]} ]]
                    then
                        eval "${sections[${section_number} X_dacti_win_sg]}"
                    else
                        wmctrl -i -a "${xids[0]}"
                    fi
                    ;;
            *)
                    if [[ ${sections[${section_number} X_dacti_win_pl]} ]]
                    then
                        eval "${sections[${section_number} X_dacti_win_pl]}"
                    else
                        for i in "${xids[@]}"
                        do
                            wmctrl -i -a "$i"
                        done
                    fi
                    ;;
        esac
    }

    __dacti_exec_selection()
    {
        command -v "${selection% *}" 1>/dev/null 2>&1 || return 1
        selection=${sections[${section_number} Exec]:-$selection}

        if [[ ${sections[${section_number} Terminal]} =~ (1|true|yes) && ( ${sections[${section_number} X_dacti_new_term]} =~ (1|true|yes) || $invocation_mode == gui ) ]]
        then
            (exec ${term} -e "$selection;${SHELL:-bash}" 2>/dev/null &)
        else
            (exec ${selection} 2>/dev/null &)
        fi
    }

    __dacti_build_new_file()
    {
        declare \
                action_name= \
                Actions= \
                key= \
                val=

        if [[ -f ${xdg_applications_home}/${selection% *}.desktop ]]
        then
            name=$(__dacti_menu "Enter a name" <<< "${selection% *}")
            action_name=${selection% *}_${RANDOM}
            while IFS='=' read -r key val
            do
                [[ $key == Actions ]] && Actions=$val && break
            done < "${xdg_applications_home}/${selection% *}.desktop"
            Actions=${Actions:+${Actions%%;}\;}${action_name}\;
            sed -i -e "s/^\(Actions=\).*$/\1${Actions}/" "${xdg_applications_home}/${selection% *}.desktop"
            printf '%s\n' "
[Desktop Action ${action_name}]
Exec=${selection}
Name=${name:-${selection% *}}
X-dacti_mode=${sections[${section_number} X_dacti_mode]}
X-dacti_new_term=${sections[${section_number} X_dacti_new_term]}
X-dacti_status=${sections[${section_number} X_dacti_status]}
X-dacti_win_pl=
X-dacti_win_sg=" >> "${xdg_applications_home}/${selection% *}.desktop"
        __dacti_logger "${selection% *}: An already existed Desktop File has been updated."
        else
        printf '%s\n' "${sections[${section_number} X_dacti_status]} ${sections[${section_number} X_dacti_mode]} ${selection% *} ${xdg_applications_home}/${selection% *}.desktop" >> "$DACTI_APPS_INDEX_FILE"
        printf '%s\n' "[Desktop Entry]
Actions=
Categories=
Comment=
DBusActivatable=
DocPath=
Exec=$selection
GenericName=
Hidden=
Icon=
InitialPreference=
Keywords=
MimeType=
Name=${selection% *}
NoDisplay=
NotShowIn=
OnlyShowIn=
Path=
ServiceTypes=
StartupNotify=
StartupWMClass=$startup_wmclass
Terminal=${sections[${section_number} Terminal]}
TryExec=
Type=Application
Version=1.1
X-dacti_mode=${sections[${section_number} X_dacti_mode]}
X-dacti_new_term=${sections[${section_number} X_dacti_new_term]}
X-dacti_status=${sections[${section_number} X_dacti_status]}
X-dacti_win_pl=
X-dacti_win_sg=" > "${xdg_applications_home}/${selection% *}.desktop"
        chmod 755 "${xdg_applications_home}/${selection% *}.desktop"
        __dacti_logger "${selection% *}: New Desktop File has been created."
        fi
    }

    (($# == 0)) && return 1

    declare \
            apps_app= \
            apps_file= \
            apps_mode= \
            apps_status= \
            build_new_file= \
            key= \
            mode= \
            new_terminal= \
            pretend= \
            section_number=0 \
            selec= \
            selection=$@ \
            status= \
            terminal= \
            val=

    declare -A sections

    case $selection in
        "")
                return 1
                ;;
        :*)
                [[ $selection =~ ^:.*b.*[[:space:]].*$ ]] && status=block
                [[ $selection =~ ^:.*c.*[[:space:]].*$ ]] && terminal=true && mode=cli
                [[ $selection =~ ^:.*i.*[[:space:]].*$ ]] && status=ign
                [[ $selection =~ ^:.*n.*[[:space:]].*$ ]] && new_terminal=true
                [[ $selection =~ ^:.*p.*[[:space:]].*$ ]] && pretend=pretend
                [[ $selection =~ ^:.*r.*[[:space:]].*$ ]] && status=reg
                [[ $selection =~ ^:.*t.*[[:space:]].*$ ]] && terminal=true && mode=tui
                [[ $selection =~ ^:.*u.*[[:space:]].*$ ]] && build_new_file=build_new_file
                selection=${selection#:* }
                ;;
    esac

    [[ $pretend != pretend && $build_new_file != build_new_file ]] &&
    {
        while read -r apps_status apps_mode apps_app apps_file
        do
            [[ $apps_app == ${selection% *} && -f $apps_file ]] &&
            {
                while IFS='=' read -r key val
                do
                    if [[ $key =~ ^\[.*\]$ ]]
                    then
                        ((section_number++))
                    elif [[ $key =~ ^(Name|Exec|Terminal|StartupWMClass|X-dacti_mode|X-dacti_new_term|X-dacti_status|X-dacti_win_sg|X-dacti_win_pl)$ ]]
                    then
                        sections[${section_number} ${key/-/_}]=$val
                    fi
                done < "$apps_file"
            }
        done < "$DACTI_APPS_INDEX_FILE"

        case $section_number in
            0)
                    build_new_file=build_new_file
                    ;;
            [^1])
                    read -r -d ']' section_number <<< "$(for ((i=1 ; i <= ${section_number[@]} ; i++)); do printf '[%s] %s: $ %s\n' "$i" "${sections[${i} Name]}" "${sections[${i} Exec]}"; done | __dacti_menu "SELECTION")"
                    section_number=${section_number/\[/}
                    [[ ! $section_number ]] &&
                    {
                        read -r -d ']' selec < <(printf '%s\n' '[1] return' "[2] Exec: $ ${selection}" "[3] Set options and exec: $ ${selection}" "[4] Edit command and set options." | __dacti_menu "SELECTION")
                        case ${selec/\[/} in
                            4)
                                    selection=$(__dacti_menu "COMMAND" <<< "$selection")
                                    ;&
                            3)
                                    selec=$(__dacti_menu "OPTIONS [bcinrtu]" <<< ":")
                                    [[ $selec =~ ^:.*b.*$ ]] && status=block
                                    [[ $selec =~ ^:.*c.*$ ]] && terminal=true && mode=cli
                                    [[ $selec =~ ^:.*i.*$ ]] && status=ign
                                    [[ $selec =~ ^:.*n.*$ ]] && new_terminal=true
                                    [[ $selec =~ ^:.*r.*$ ]] && status=reg
                                    [[ $selec =~ ^:.*t.*$ ]] && terminal=true && mode=tui
                                    [[ $selec =~ ^:.*u.*$ ]] && build_new_file=build_new_file
                                    [[ ! $selection ]] && return 1
                                    ;&
                            2)
                                    section_number=0
                                    ;;
                            *)
                                    return 1
                                    ;;
                        esac
                    }
                    ;;
        esac
    }

    sections[${section_number} X_dacti_status]=${status:-${sections[${section_number} X_dacti_status]}}
    sections[${section_number} X_dacti_status]=${sections[${section_number} X_dacti_status]:-reg}
    sections[${section_number} Terminal]=${terminal:-${sections[${section_number} Terminal]}}
    sections[${section_number} X_dacti_new_term]=${new_terminal:-${sections[${section_number} X_dacti_new_term]}}
    sections[${section_number} X_dacti_mode]=${mode:-${sections[${section_number} X_dacti_mode]}}
    sections[${section_number} X_dacti_mode]=${sections[${section_number} X_dacti_mode]:-gui}

    case ${sections[${section_number} X_dacti_status]} in
        block)      [[ ! $build_new_file ]] && __dacti_logger "${selection% *}: block status true." && return 1 ;;
        ign)        __dacti_logger "${selection% *}: ign status true." && __dacti_exec_selection ;;
        *)          __dacti_check_wins ;;
    esac

    [[ $build_new_file ]] && __dacti_build_new_file
    printf '%s\n' "$(date +%Y-%m-%d_%H:%M) launch ${selection% *}" >> "$DACTI_LOG_FILE"

    __dacti_status_code 0 "Quit: Execution has finished."
}

__dacti_selection_0()
{
    declare \
            apps_app= \
            apps_file= \
            apps_mode= \
            apps_status=

    printf '[%s]\n' "${menu_0[@]}"
    [[ $(stat -c %s "$DACTI_APPS_INDEX_FILE" 2>/dev/null) -ge 2 ]] &&
    {
        while read -r apps_status apps_mode apps_app apps_file
        do
            [[ $apps_status != block ]] && printf '%s\n' "$apps_app"
        done < "$DACTI_APPS_INDEX_FILE"
    } | sort
}

__dacti_comm_array()
{
    declare \
            arg= \
            counter= \
            element_array_1= \
            element_array_2= \
            skip=

    declare -a \
               array_1=() \
               array_2=()

    { (($#)) && counter=1 ; } || return 1

    for arg
    do
        [[ $arg == -- ]] && ((counter++))
    done

    for ((i=1 ; i <= $counter ; i++))
    do
        while [[ $# -gt 0 && $1 != -- ]]
        do
            eval "array_${i}+=( "$1" )"
            shift 1
        done
        [[ $1 == -- ]] && shift 1
    done

    for element_array_1 in "${array_1[@]}"
    do
        for element_array_2 in "${array_2[@]}"
        do
            [[ $element_array_1 == $element_array_2 ]] && { skip=1 ; break ; }
        done
        ((skip)) || printf '%s\n' "$element_array_1"
        skip=
    done
}

__dacti_index_applications()
{
    declare \
            file= \
            mode= \
            path=

    if [[ -f $DACTI_APPS_CACHE_FILE ]]
    then
        comm -23 <(find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -printf '%T@ %p\n' | sort -n | tee "${DACTI_APPS_CACHE_FILE}.$$") "$DACTI_APPS_CACHE_FILE" |
        while read -r _ file
        do
            path=$file
            file=${file##*/}
            mode=gui
            sed -i -e "/^.* \<${file%.desktop}\> .*/ d" "$DACTI_APPS_INDEX_FILE"
            egrep -q -e 'Terminal=(1|[tT]rue|[yY]es)' "$path" && mode=cli
            printf '%s\n' "reg ${mode:-gui} ${file%.desktop} ${path}" >> "$DACTI_APPS_INDEX_FILE"
        done
        mv -- "${DACTI_APPS_CACHE_FILE}.$$" "${DACTI_APPS_CACHE_FILE}"
    else
        exec 3>>"$DACTI_APPS_INDEX_FILE"
        find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -printf '%T@ %p\n' | sort -n | tee "$DACTI_APPS_CACHE_FILE" |
        while read -r _ file
        do
            path=$file
            file=${file##*/}
            mode=gui
            egrep -q -e 'Terminal=(1|[tT]rue|[yY]es)' "$path" && mode=cli
            printf '%s\n' "reg ${mode:-gui} ${file%.desktop} ${path}" 1>&3
        done
        exec 3<&-
    fi
}

__dacti_update_categories()
{
    declare \
            cats= \
            file= \
            i=

    declare -a \
               categories=() \
               main=() \
               sub=()

    cd -- "$DACTI_CATS_DATA_DIR" || return 1

    find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -exec grep -HR '^Categories' /dev/null {} + | tee "$DACTI_CATS_INDEX_FILE" |
    while IFS=':' read -r file cats
    do
        cats=${cats#Categories=}
        categories=(${cats//;/ })

        ((${#categories[@]} == 0)) && continue

        mapfile -t main < <(find . -mindepth 1 -maxdepth 1 -type d -print | fgrep -e "$(printf '%s\n' ${categories[@]})")
        mapfile -t sub < <(__dacti_comm_array "${categories[@]}" -- "${main[@]#./}")

        for i in "${sub[@]}"
        do
            grep -q "^${i}\>" "$DACTI_CATS_SUB_INFO_FILE" || unset -v "sub[$i]"
        done

        if ((${#sub[@]} > 0))
        then
            while IFS= read -rd ''
            do
                ln -f -s "$file" "$REPLY"
            done < <(find ${main[*]} -mindepth 1 -type d -print0 | grep -zZ -f <(printf '%s$\n' ${sub[@]}))
        else
            for i in "${main[@]}"
            do
                ln -f -s "$file" "$i"
            done
        fi
    done
}

__dacti_update_keywords()
{
    declare \
            file= \
            keywords=

    find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -exec grep -HR '^Keywords=' /dev/null {} + | sed -e '{s/ $//;s/$/;/;s/;;/;/;s/; /;/g}' | tee "$DACTI_KEYWS_INDEX_FILE" |
    while IFS=':' read -r file keywords
    do
        keywords=${keywords#Keywords=}
        while read -r -d ';'
        do
            printf '%s\n' "$REPLY"
        done <<< "$keywords"
    done | sort | uniq > "$DACTI_KEYWS_CACHE_FILE"
}

__dacti_check_args()
{
    declare o=
    if [[ ! $OPTARG =~ -.+ ]]
    then
        for o
        do
            declare -g "$o"
        done
    else
        { printf '%s\n' "Option -${opt} requires an argument." 1>&2 ; exit 1 ; }
    fi
}

__dacti_status_code()
{
    declare \
            status_code=$1 \
            status_message=$2

    if (($status_code == 0))
    then
        printf '%s\n' "$(date +%Y-%m-%d_%H:%M) success ${status_message}" >> "$DACTI_LOG_FILE"
    else
        printf '%s\n' "${0##*/}:Status:Error:${status_code}: ${error_message}" 1>&2
        printf '%s\n' "$(date +%Y-%m-%d_%H:%M) error ${status_message}" >> "$DACTI_LOG_FILE"
    fi

    exit "$status_code"
}

__dacti_logger()
{
    declare log_message=$1
    printf '%s\n' "$(date +%Y-%m-%d_%H:%M) event ${log_message}" >> "$DACTI_LOG_FILE"
}

# -- MAIN.

declare \
        arg= \
        args= \
        delim= \
        opt=

for arg
do
    arg=${arg#--}
    case $arg in
        conf-file=*)            args="${args}-C ${arg#*=} "            ;;
        index-applications)     args="${args}-x "                      ;;
        quit)                   args="${args}-q "                      ;;
        update-categories)      args="${args}-c "                      ;;
        update-keywords)        args="${args}-k "                      ;;
        *)                      [[ ${arg:0:1} != - ]] && delim=\"
                                args="${args}${arg} "
                                delim=                                 ;;
    esac
done

declare \
        index_applications= \
        quit= \
        update_categories= \
        update_keywords=

eval set -- $args
while getopts :cC:kqx opt
do
    case $opt in
        c)      update_categories=update_categories                   ;;
        C)      __dacti_check_args "DACTI_CONF_FILE=$OPTARG"          ;;
        k)      update_keywords=update_keywords                       ;;
        q)      quit=quit                                             ;;
        x)      index_applications=index_applications                 ;;
    esac
done
shift $((OPTIND-1))

declare -r \
           predir_datadir=${XDG_DATA_HOME:-${HOME}/.local/share} \
           predir_configdir=${XDG_CONFIG_HOME:-${HOME}/.config}

declare -r DACTI_CONF_FILE=${DACTI_CONF_FILE:-${predir_configdir}/dacti}/dacti.conf

declare -A d_color

if [[ -f $DACTI_CONF_FILE ]]
then
    source "$DACTI_CONF_FILE" 2>/dev/null || { printf '%s\n' "${0##*/}:Status:Error:1: ${DACTI_CONF_FILE} has not been sourced." 1>&2 ; exit 1 ; }
else
     { printf '%s\n' "${0##*/}:Status:Error:1: ${$DACTI_CONF_FILE} is not a regular file." 1>&2 ; exit 1 ; }
fi

declare -r DACTI_DATA_DIR=${DACTI_DATA_DIR:-${predir_datadir}/dacti} \

declare -r \
           DACTI_APPS_INDEX_FILE=${DACTI_APPS_INDEX_FILE:-${DACTI_DATA_DIR}/dacti_applications.index} \
           DACTI_APPS_CACHE_FILE=${DACTI_APPS_CACHE_FILE:-${DACTI_DATA_DIR}/dacti_applications.cache} \
           DACTI_CATS_DATA_DIR=${DACTI_CATS_DATA_DIR:-${DACTI_DATA_DIR}/Categories} \
           DACTI_CATS_INDEX_FILE=${DACTI_CATS_INDEX_FILE:-${DACTI_DATA_DIR}/dacti_categories.index} \
           DACTI_CATS_MAIN_INFO_FILE=${DACTI_CATS_MAIN_INFO_FILE:-${DACTI_DATA_DIR}/dacti_categories_main.info} \
           DACTI_CATS_SUB_INFO_FILE=${DACTI_CATS_SUB_INFO_FILE:-${DACTI_DATA_DIR}/dacti_categories_sub.info} \
           DACTI_KEYWS_INDEX_FILE=${DACTI_KEYWS_INDEX_FILE:-${DACTI_DATA_DIR}/dacti_keywords.index} \
           DACTI_KEYWS_CACHE_FILE=${DACTI_KEYWS_CACHE_FILE:-${DACTI_DATA_DIR}/dacti_keywords.cache} \
           DACTI_LOG_FILE=${DACTI_LOG_FILE:-${DACTI_DATA_DIR}/dacti.log} \
           DACTI_TMP_DIR=${DACTI_TMP_DIR:-${TMPDIR:-/tmp}} \
           xdg_data_dirs=${XDG_DATA_DIRS:-/usr/local/share:/usr/share}

declare -r DACTI_APPS_DIRS=${DACTI_APPS_DIRS:-${xdg_data_dirs}}

declare -r term=${term:-xterm} \
           xdg_applications_home=${xdg_applications_home:-${predir_datadir}/applications}

declare -a xdg_applications=(${DACTI_APPS_DIRS//:/ })
declare -ra xdg_applications=(${xdg_applications[@]/%/\/applications})

declare -a menu_0=(${menu_0[@]:-CATEGORIES KEYWORDS BIN-ASC BIN-DESC BIN-ATIME-ASC BIN-ATIME-DESC LOG OCCUR})

declare \
        invocation_mode= \
        menu_cmd= \
        selection=

[[ $log_file == true ]] || declare log_file=
[[ $xmessage == true ]] || declare xmessage=

if command -v "dmenu2" 1>/dev/null 2>&1
then
    menu_cmd=dmenu2
else
    menu_cmd=dmenu
fi

if tty 1>/dev/null 2>&1
then
    invocation_mode=cli
    command -v "slmenu" 1>/dev/null 2>&1 && menu_cmd=slmenu
elif [[ $DISPLAY ]]
then
    invocation_mode=gui
else
    { printf '%s\n' "${0##*/}:Status:Error:1: Neither cli nor gui mode." 1>&2 ; exit 1 ; }
fi

[[ -d $DACTI_DATA_DIR ]] || mkdir -p "$DACTI_DATA_DIR"
[[ -f $DACTI_APPS_INDEX_FILE ]] || > "$DACTI_APPS_INDEX_FILE"

[[ $index_applications == index_applications ]] && __dacti_index_applications
[[ $update_categories == update_categories ]] && __dacti_update_categories
[[ $update_keywords == update_keywords ]] && __dacti_update_keywords
[[ $quit == quit ]] && __dacti_status_code 0 "Quit: With these command line options: ${index_applications/%/ }${update_categories/%/ }${update_keywords}."

unset -v \
         arg \
         args \
         delim \
         index_applications \
         opt \
         quit \
         update_categories \
         update_keywords

while :
do
    selection=$(__dacti_selection_0 | __dacti_menu)
    case ${selection,,} in
        \[bin-asc\])        __dacti_check_status "$(__dacti_bin_asc | __dacti_menu "BIN-ASC")" ;;
        \[bin-atime-asc\])  __dacti_check_status "$(__dacti_bin_atime_asc | __dacti_menu "BIN-ATIME-ASC")" ;;
        \[bin-atime-desc\]) __dacti_check_status "$(__dacti_bin_atime_desc | __dacti_menu "BIN-ATIME-DESC")" ;;
        \[bin-desc\])       __dacti_check_status "$(__dacti_bin_desc | __dacti_menu "BIN-DESC")" ;;
        *\[categories\])    __dacti_browse_categories "$selection" ;;
        *\[keywords\])      __dacti_browse_keywords "$selection" ;;
        \[log\])            selection=$(__dacti_browse_log | __dacti_menu "LOG") &&
                            [[ $selection =~ (^.* launch .*$) ]] &&
                            __dacti_check_status "${selection#* * }" || continue ;;
        \[occur\])          selection=$(__dacti_occur | __dacti_menu "OCCUR") && __dacti_check_status "${selection#      * }" ;;
        "")                 __dacti_status_code 0 "Quit: Nothing has been chosen." ;;
        *)                  { declare -f __dacti_selection_custom > /dev/null && __dacti_selection_custom "$selection" ; } || __dacti_check_status "$selection" ;;
    esac
done
