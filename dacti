#!/usr/bin/env bash

# Copyright 2014 D630
# https://github.com/D630/dacti

# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.

# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.

# You should have received a copy of the GNU General
# Public License along with this program. If not, see
# <http://www.gnu.org/licenses/gpl-3.0.html>.

# -- DEBUGGING.

#printf '%s (%s)\n' "$BASH_VERSION" "${BASH_VERSINFO[5]}" && exit 0
#set -o xtrace #; exec 2>> ~/dacti.log
#set -o verbose
#set -o noexec
#set -o errexit
#set -o nounset
#set -o pipefail
#trap '(read -p "[$BASH_SOURCE:$LINENO] $BASH_COMMAND?")' DEBUG

# -- SETTINGS.

#declare vars_base=$(set -o posix ; set)

# -- FUNCTIONS.

__dacti_version() { echo "0.1.0.3" ; }

__dacti_help()
{
    printf '%s\n' 'dacti (-h|-v|) [-C] [-a|-c|-k|-q]

    Cli
      -a   --update-applications Index all desktop files.
      -C,  --conf-file=<FILE>    Source a file as conf file.
      -c,  --update-categories   Index all categories.
      -h,  --help
      -k,  --update-keywords     Index all keywords.
      -p,  --pretend             Like ":p". Pretend indexing and building
                                 of desktop files.
      -q,  --quit                Quit before performing the main
                                 selection menu.
      -v,  --version

    Main selection menu
      [BIN-ASC]                  Browse all binaries inside the enviroment
                                 variable <PATH> in a selection menu. Sort
                                 them in ascending order by its names.
      [BIN-DESC]                 Browse all binaries inside the enviroment
                                 variable <PATH> in a selection menu. Sort
                                 them in descending order by its names.
      [BIN-ATIME-ASC]            Browse all binaries inside the enviroment
                                 variable <PATH> in a selection menu. Sort
                                 them in ascending order by its access time.
      [BIN-ATIME-DESC]           Browse all binaries inside the enviroment
                                 variable <PATH> in a selection menu. Sort
                                 them in descending order by its access
                                 time.
      [CATEGORIES]               Browse all categories in a selection menu
                                 and select associated desktop files.
        :u [CATEGORIES]          Update the category index before.
      [KEYWORDS]                 Browse keywords in a selection menu and
                                 select associated desktop files.
        :u [KEYWORDS]            Update the keyword index before.
        :q [KEYWORDS]            Invoke a query menu and look for desktop
                                 files.
      [LOG]                      Browse all log entries of dacti in a
                                 selection menu. Start applications from
                                 it by selecting
                                 entries with the event "launch".
      [OCCUR]                    Browse applications by its occurence
                                 based on the log file.

    Application
      <APP>                      Launch application.
        :b <APP>                 Declare status "block".
        :c <APP>                 App has a cli and needs a terminal (mode=cli).
        :i <APP>                 Declare status "ign".
        :n <APP>                 App should start in a new terminal instance.
        :p <APP>                 Dont check, if app is indexed. Launch it
                                 directly and create no new desktop file.
        :t <APP>                 Apps has a tui and needs a terminal (mode=tui).
        :u <APP>                 Dont check, if app is indexed. Launch it
                                 directly and create a new desktop file or
                                 entry.
'
}

__dacti_bin_asc() { lsx ${PATH//:/ } | sort | uniq ; }

__dacti_bin_atime_asc() { find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' | sort -n | cut -f2 | fgrep -xf <(lsx ${PATH//:/ }) | uniq  ; }

__dacti_bin_atime_desc() { find ${PATH//:/ } \( -type f -o -type l \) -printf '%A@\t%P\n' | sort -rn | cut -f2 | fgrep -xf <(lsx ${PATH//:/ }) | uniq ; }

__dacti_bin_desc() { lsx ${PATH//:/ } | sort -r | uniq ; }

__dacti_menu_cmd()
{
    if declare -f __dacti_menu_cmd_custom 1>/dev/null 2>&1
    then
        __dacti_menu_cmd_custom "${1:-${menu_0_prompt}}"
    else
        dmenu -p "${1:-${menu_0_prompt}}"
    fi
}

__dacti_occur() { grep -e '^.* launch .*$' "$DACTI_LOG_FILE" | cut -d ' ' -f3 | sort | uniq -c | sort -nr ; }

__dacti_browse_log() { sort -rn "$DACTI_LOG_FILE" ; }

__dacti_browse_categories()
{
    (($# == 0)) && return 1

    declare \
            selection=$1 \
            parent=

    # Update categories before, if wanted with ":u".
    [[ $selection =~ ^:.*u.*[[:space:]].*$ ]] &&
    {
        __dacti_update_categories && __dacti_logger "Categories: Update has been processed."
        selection=${selection#:* }
    }

    # Now handle the selection menu and perform selections.
    read -r selection < <(find "$DACTI_CATS_DATA_DIR" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' | sort | __dacti_menu_cmd "CATEGORIES")
    parent=${DACTI_CATS_DATA_DIR##*/}/${selection}
    while [[ $selection ]]
    do
        read -r selection < <({ printf '%s\n' '[..]' '[.]' ; find "${DACTI_CATS_DATA_DIR%/*}/${parent}" -mindepth 1 -maxdepth 1 -printf '%f\n' ; } | sort | __dacti_menu_cmd ${parent##*/})
        case $selection in
            \[..\])     parent=${parent%/*}                           ;;
            \[.\])      parent=$parent                                ;;
            *.desktop)  __dacti_check_status "${selection%.desktop}"  ;;
            *)          parent=${parent}/${selection}                 ;;
        esac
    done
}

__dacti_browse_keywords()
{
    __dacti_search_post()
    {
        declare key=

        if [[ ( ${operators[or]} && ${operators[not]} ) || ${operators[or]} ]]
        then
            for key in "${!search[@]}"
            do
                [[ $key =~ (^not*|^and*) ]] && continue
                [[ ${search[$key]} == ${search[${key/or/not}]} ]] &&
                {
                    unset -v "search[$key]"
                    unset -v "search[${key/or/not}]"
                }
            done

            [[ ${operators[and]} ]] &&
            {
                for key in "${!search[@]}"
                do
                    [[ $key =~ ^and* ]] && continue
                    if [[ ${search[$key]} == ${search[${key/or/and}]} ]]
                    then
                        unset -v "search[${key/or/and}]"
                    else
                        unset -v "search[$key]"
                    fi
                done
            }

            for key in "${!search[@]}"
            do
                [[ ! $key =~ ^and* ]] && search[${key/or /}]=1
                unset -v "search[$key]"
            done
        elif [[ ${operators[not]} ]]
        then
            for key in "${!search[@]}"
            do
                [[ $key =~ ^not* ]] &&
                {
                    keyy=${key/not /}
                    search[${keyy% *}]=1
                }
                unset -v "search[$key]"
            done

            for key in "${!search[@]}"
            do
                [[ $key =~ [[:blank:]] ]] || unset -v "search[$key]"
            done
        fi
    }

    (($# == 0)) && return 1

    declare \
            file= \
            i= \
            keywords= \
            operator= \
            parent= \
            query= \
            query_keywords= \
            selection=$1

    declare -A search \
               operators

    # If wanted with ":u", update keywords before.
    [[ $selection == :* ]] &&
    {
        [[ $selection =~ ^:.*u.*[[:space:]].*$ ]] && __dacti_update_keywords && __dacti_logger "Keywords: Update has been proccessed."
        [[ $selection =~ ^:.*q.*[[:space:]].*$ ]] && query_keywords=query_keywords
        selection=${selection#:* }
    }

    if [[ $query_keywords ]]
    then
        # Perform selection menu with an interactive query.
        selection=
        query=($(__dacti_menu_cmd "QUERY" 0<&-))

        for i in "${query[@]}"
        do
            [[ $i =~ ^(and|not|or)$ ]] && operator=$i && continue
            operator=${operator:-or}
            operators[$operator]=1
            while IFS=':' read -r file keywords
            do
                keywords=${keywords#Keywords=}
                search[${operator} ${file}]=1
            done < <(egrep -e "^(.*):Keywords=.*${i};.*$" "$DACTI_KEYWS_INDEX_FILE")
        done

        __dacti_search_post

        selection=$(for key in "${!search[@]}" ; do printf '%s\n' "${key##*/}" ; done | __dacti_menu_cmd "MATCH")
        [[ $selection ]] && __dacti_check_status "${selection%.desktop}"
    else
        # Just perform the selection menu.
        read -r selection < <(__dacti_menu_cmd "KEYWORDS" < "$DACTI_KEYWS_CACHE_FILE")
        while [[ $selection ]]
        do
            parent=$selection
            read -r selection < <({ printf '%s\n' '[..]' '[.]' ; while IFS=':' read -r file keywords ; do printf '%s\n' "${file##*/}" ; done < <(egrep -e "^(.*):Keywords=.*${selection};.*$" "$DACTI_KEYWS_INDEX_FILE") ; }| __dacti_menu_cmd "$parent")
            case $selection in
                \[.\])      selection=$parent                                                           ;;
                \[..\])     read -r selection < <(__dacti_menu_cmd "KEYWORDS" < "$DACTI_KEYWS_CACHE_FILE")  ;;
                *)          __dacti_check_status "${selection%.desktop}"                                ;;
            esac
        done
    fi
}

__dacti_check_status()
{
    __dacti_do_win_sg() { wmctrl -i -a "${xids[0]}" ; }

    __dacti_do_win_pl()
    {
        declare fail=

        for i in "${xids[@]}"
        do
            wmctrl -i -a "$i" || { launch_status=fail ; __dacti_logger "Raising: Window ${i} of ${selection% *} has not raised." ; }
        done
    }

    __dacti_check_wins()
    {
        declare \
                i= \
                id= \
                fail= \
                net_client_list= \
                net_wm_pid= \
                pid=

        declare -g startup_wmclass=

        declare -a \
                   pid_list=() \
                   xids=()

        read -r _ _ _ _ net_client_list < <(xprop -root _NET_CLIENT_LIST)

        if [[ ${sections[${section_number} X_dacti_mode]} != gui ]]
        then
            # If application has the status "cli" or "tui", search the window id of its parent pid (a terminal).
            for pid in $(pgrep -d ' ' "${selection% *}")
            do
                until [[ ${pid// /} == 0 ]]
                do
                    pid=$(ps -p "${pid// /}" -o ppid= 2>/dev/null)
                    pid_list+=(${pid// /})
                done
            done
            for id in ${net_client_list//,/}
            do
                read -r _ _ net_wm_pid < <(xprop -id "$id" _NET_WM_PID)
                for pid in "${pid_list[@]}"
                do
                    [[ $net_wm_pid == $pid ]] && xids+=($id)
                done
            done
        else
            # Just search the window id of the application itself (status=gui).
            for id in ${net_client_list//,/}
            do
                [[ $(xprop -id "$id" WM_CLASS) =~ ${sections[${section_number} StartupWMClass]:-${selection% *}} ]] &&
                xids+=($id) &&
                startup_wmclass=${BASH_REMATCH[0]}
            done
        fi

        # Now we decide, what to do relative to the number of collected window ids.
        case ${#xids[@]} in
            0)
                    __dacti_exec_selection
                    ;;
            1)
                    if [[ ${sections[${section_number} X_dacti_win_sg]} ]]
                    then
                        eval "${sections[${section_number} X_dacti_win_sg]}"
                    else
                        if declare -f __dacti_do_win_sg_custom 1>/dev/null 2>&1
                        then
                            __dacti_do_win_sg_custom || fail=fail
                        else
                            __dacti_do_win_sg || fail=fail
                        fi
                        [[ $fail == fail ]] && { launch_status=fail ; __dacti_logger "Raising: Window of ${selection% *} has not raised." ; }
                    fi
                    ;;
            *)
                    if [[ ${sections[${section_number} X_dacti_win_pl]} ]]
                    then
                        eval "${sections[${section_number} X_dacti_win_pl]}"
                    else
                        if declare -f __dacti_do_win_pl_custom 1>/dev/null 2>&1
                        then
                            __dacti_do_win_pl_custom
                        else
                            __dacti_do_win_pl
                        fi
                    fi
                    ;;
        esac
    }

    __dacti_exec_selection()
    {
        # Check, if selected command, exists.
        if command -v "${selection% *}" 1>/dev/null 2>&1
        then
            selection=${sections[${section_number} Exec]:-$selection}

            # Check, if selected command needs to have a terminal; relative to the invocation mode and option ":n".
            if [[ ${sections[${section_number} Terminal]} =~ (1|true|yes) && ( ${sections[${section_number} X_dacti_new_term]} =~ (1|true|yes) || $invocation_mode == gui ) ]]
            then
                (exec ${term} -e "$selection;${SHELL:-bash}" 2>/dev/null &)
            else
                (exec ${selection} 2>/dev/null &)
            fi
        else
            launch_status=fail
            __dacti_logger "Execution: Command ${selection% *} is unknown."
            return 1
        fi
    }

    __dacti_build_new_file()
    {
        declare \
                action_name= \
                Actions= \
                key= \
                val=

        if [[ -f ${xdg_applications_home}/${selection% *}.desktop ]]
        then
            # If a desktop file has already been created in "${xdg_applications_home}", then its desktop file needs to be updated. We insert then a new application section/group.
            name=$(__dacti_menu_cmd "Give a name" <<< "${selection% *}")
            [[ ! $name ]] && { __dacti_logger "File creation: aborted." ; return 1 ; }

            action_name=${selection% *}_${RANDOM}
            while IFS='=' read -r key val
            do
                [[ $key == Actions ]] && Actions=$val && break
            done < "${xdg_applications_home}/${selection% *}.desktop"
            Actions=${Actions:+${Actions%%;}\;}${action_name}\;

            sed -i -e "s/^\(Actions=\).*$/\1${Actions}/" "${xdg_applications_home}/${selection% *}.desktop"

            printf '%s\n' "
[Desktop Action ${action_name}]
Exec=${selection}
Name=${name:-${selection% *}}
StartupWMClass=$startup_wmclass
Terminal=${sections[${section_number} Terminal]}
X-dacti_mode=${sections[${section_number} X_dacti_mode]}
X-dacti_new_term=${sections[${section_number} X_dacti_new_term]}
X-dacti_status=${sections[${section_number} X_dacti_status]}
X-dacti_win_pl=
X-dacti_win_sg=" 1>> "${xdg_applications_home}/${selection% *}.desktop"

            # Index file?
            if egrep -q -e "(.*) (.*) ${selection% *} ${xdg_applications_home}/${selection% *}.desktop" "$DACTI_APPS_INDEX_FILE"
            then
                __dacti_logger "File creation: File has already been indexed."
            else
                printf '%s\n' "${sections[${section_number} X_dacti_status]} ${sections[${section_number} X_dacti_mode]} ${selection% *} ${xdg_applications_home}/${selection% *}.desktop" 1>> "$DACTI_APPS_INDEX_FILE"
            fi

            __dacti_logger "${selection% *}: An already existed Desktop File has been updated."
        else
            # Create new desktop file with all official keys + dactis own keys.
            printf '%s\n' "${sections[${section_number} X_dacti_status]} ${sections[${section_number} X_dacti_mode]} ${selection% *} ${xdg_applications_home}/${selection% *}.desktop" 1>> "$DACTI_APPS_INDEX_FILE"

            printf '%s\n' "[Desktop Entry]
Actions=
Categories=
Comment=
DBusActivatable=
DocPath=
Exec=$selection
GenericName=
Hidden=
Icon=
InitialPreference=
Keywords=
MimeType=
Name=${selection% *}
NoDisplay=
NotShowIn=
OnlyShowIn=
Path=
ServiceTypes=
StartupNotify=
StartupWMClass=$startup_wmclass
Terminal=${sections[${section_number} Terminal]}
TryExec=
Type=Application
Version=1.1
X-dacti_mode=${sections[${section_number} X_dacti_mode]}
X-dacti_new_term=${sections[${section_number} X_dacti_new_term]}
X-dacti_status=${sections[${section_number} X_dacti_status]}
X-dacti_win_pl=
X-dacti_win_sg=" 1> "${xdg_applications_home}/${selection% *}.desktop"

            chmod 755 "${xdg_applications_home}/${selection% *}.desktop"

            __dacti_logger "${selection% *}: New Desktop File has been created."
        fi
    }

    (($# == 0)) && return 1

    declare \
            apps_app= \
            apps_file= \
            apps_mode= \
            apps_status= \
            build_new_file= \
            key= \
            launch_status= \
            mode= \
            new_terminal= \
            pretend=${pretend} \
            section_number=0 \
            selec= \
            selection=$@ \
            status= \
            terminal= \
            val=

    declare -A sections

    # Check, if selected application has been invoked with options (:bcinprtu).
    case $selection in
        "")
                return 1
                ;;
        :*)
                [[ ${selection%% *} =~ ^:.*b.*$ ]] && status=block
                [[ ${selection%% *} =~ ^:.*c.*$ ]] && terminal=true && mode=cli
                [[ ${selection%% *} =~ ^:.*i.*$ ]] && status=ign
                [[ ${selection%% *} =~ ^:.*n.*$ ]] && new_terminal=true
                [[ ${selection%% *} =~ ^:.*p.*$ ]] && pretend=pretend
                [[ ${selection%% *} =~ ^:.*t.*$ ]] && terminal=true && mode=tui
                [[ ${selection%% *} =~ ^:.*u.*$ ]] && build_new_file=build_new_file
                selection=${selection#:* }
                ;;
    esac

    # If option ":p" and ":u" have not been set, then we will look for the application in the application index file and declare some variables.
    [[ $pretend != pretend && $build_new_file != build_new_file ]] &&
    {
        #status=reg
        #terminal=
        #new_terminal=

        while read -r apps_status apps_mode apps_app apps_file
        do
            [[ $apps_app == ${selection% *} && -f $apps_file ]] &&
            {
                while IFS='=' read -r key val
                do
                    if [[ $key =~ ^\[.*\]$ ]]
                    then
                        ((section_number++))
                    elif [[ $key =~ ^(Name|Exec|Terminal|StartupWMClass|X-dacti_mode|X-dacti_new_term|X-dacti_status|X-dacti_win_sg|X-dacti_win_pl)$ ]]
                    then
                        sections[${section_number} ${key/-/_}]=$val
                    fi
                done < "$apps_file"
            }
        done < "$DACTI_APPS_INDEX_FILE"

        # If application has been indexed and has more than one exec key, then decide, what to do.
        case $section_number in
            0)
                    build_new_file=build_new_file
                    ;;
            [^1])
                    read -r -d ']' section_number <<< "$(for ((i=1 ; i <= ${section_number[@]} ; i++)); do printf '[%s] [%s] [%s] $ %s\n' "$i" "${sections[${i} X_dacti_status]};${sections[${i} X_dacti_mode]};${sections[${i} X_dacti_new_term]}" "${sections[${i} Name]}" "${sections[${i} Exec]}"; done | __dacti_menu_cmd "SELECTION")"
                    section_number=${section_number/\[/}

                    [[ ! $section_number ]] &&
                    {
                        read -r -d ']' selec < <(printf '%s\n' '[1] return' "[2] Exec: $ ${selection}" "[3] Set options and exec: $ ${selection}" "[4] Edit command and set options." | __dacti_menu_cmd "SELECTION")
                        case ${selec/\[/} in
                            4)
                                    selection=$(__dacti_menu_cmd "COMMAND" <<< "$selection")
                                    ;&
                            3)
                                    selec=$(__dacti_menu_cmd "OPTIONS [bcintu]" <<< ":")
                                    [[ ${selec%% *} =~ ^:.*b.*$ ]] && status=block
                                    [[ ${selec%% *} =~ ^:.*c.*$ ]] && terminal=true && mode=cli
                                    [[ ${selec%% *} =~ ^:.*i.*$ ]] && status=ign
                                    [[ ${selec%% *} =~ ^:.*n.*$ ]] && new_terminal=true
                                    [[ ${selec%% *} =~ ^:.*t.*$ ]] && terminal=true && mode=tui
                                    [[ ${selec%% *} =~ ^:.*u.*$ ]] && build_new_file=build_new_file
                                    [[ ! $selection ]] && return 1
                                    ;&
                            2)
                                    section_number=0
                                    ;;
                            *)
                                    return 1
                                    ;;
                        esac
                    }
                    ;;
        esac
    }

    # Set application specific variables.
    sections[${section_number} X_dacti_status]=${status:-${sections[${section_number} X_dacti_status]}}
    sections[${section_number} X_dacti_status]=${sections[${section_number} X_dacti_status]:-reg}
    sections[${section_number} Terminal]=${terminal:-${sections[${section_number} Terminal]}}
    sections[${section_number} X_dacti_new_term]=${new_terminal:-${sections[${section_number} X_dacti_new_term]}}
    sections[${section_number} X_dacti_mode]=${mode:-${sections[${section_number} X_dacti_mode]}}
    sections[${section_number} X_dacti_mode]=${sections[${section_number} X_dacti_mode]:-gui}

    # Check the status of the application.
    case ${sections[${section_number} X_dacti_status]} in
        block)      [[ ! $build_new_file ]] && __dacti_logger "${selection% *}: block status true." && return 1 ;;
        ign)        __dacti_logger "${selection% *}: ign status true." && __dacti_exec_selection ;;
        reg)        __dacti_check_wins ;;
        *)          __dacti_status_code 1 "Quit: Status ${status} is unknown."
    esac

    if [[ $launch_status == fail ]]
    then
        __dacti_status_code 1 "Quit: Launch has failed."
    else
        # Create new desktop file, if invoked with ":u" or if there is no entry in the index file.
        [[ $build_new_file ]] && __dacti_build_new_file
        printf '%s\n' "$(date +%Y-%m-%d_%H:%M:%N) launch ${selection% *}" 1>> "$DACTI_LOG_FILE"
        __dacti_status_code 0 "Quit: Execution has finished."
    fi
}

__dacti_selection_0()
{
    declare \
            apps_app= \
            apps_file= \
            apps_mode= \
            apps_status=

    printf '[%s]\n' "${menu_0[@]}"
    [[ $(stat -c %s "$DACTI_APPS_INDEX_FILE" 2>/dev/null) -ge 2 ]] &&
    {
        while read -r apps_status apps_mode apps_app apps_file
        do
            [[ $apps_status != block ]] && printf '%s\n' "$apps_app"
        done < "$DACTI_APPS_INDEX_FILE"
    } | sort | uniq
}

__dacti_comm_array()
{
    declare \
            arg= \
            counter= \
            element_array_1= \
            element_array_2= \
            skip=

    declare -a \
               array_1=() \
               array_2=()

    { (($#)) && counter=1 ; } || return 1

    for arg
    do
        [[ $arg == -- ]] && ((counter++))
    done

    for ((i=1 ; i <= $counter ; i++))
    do
        while [[ $# -gt 0 && $1 != -- ]]
        do
            eval "array_${i}+=( "$1" )"
            shift 1
        done
        [[ $1 == -- ]] && shift 1
    done

    for element_array_1 in "${array_1[@]}"
    do
        for element_array_2 in "${array_2[@]}"
        do
            [[ $element_array_1 == $element_array_2 ]] && { skip=1 ; break ; }
        done
        ((skip)) || printf '%s\n' "$element_array_1"
        skip=
    done
}

__dacti_update_applications()
{
    declare \
            file= \
            mode= \
            path=

    exec 3>>"$DACTI_APPS_INDEX_FILE"
    if [[ -f $DACTI_APPS_CACHE_FILE ]]
    then
        # If there is an application cache file, then compare it with the current state and update the application index file.
        while read -r _ file
        do
            path=$file
            file=${file##*/}
            mode=gui
            sed -i -e "/^.* \<${file%.desktop}\> .*/ d" "$DACTI_APPS_INDEX_FILE"
            egrep -q -e 'Terminal=(1|[tT]rue|[yY]es)' "$path" && mode=cli
            printf '%s\n' "reg ${mode:-gui} ${file%.desktop} ${path}" 1>&3
        done < <(comm -23 <(find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -printf '%T@ %p\n' | sort -n | tee "${DACTI_APPS_CACHE_FILE}.$$") "$DACTI_APPS_CACHE_FILE")
        mv -- "${DACTI_APPS_CACHE_FILE}.$$" "${DACTI_APPS_CACHE_FILE}"
    else
        # If there is no cache file, create a new index file.
        while read -r _ file
        do
            path=$file
            file=${file##*/}
            mode=gui
            egrep -q -e 'Terminal=(1|[tT]rue|[yY]es)' "$path" && mode=cli
            printf '%s\n' "reg ${mode:-gui} ${file%.desktop} ${path}" 1>&3
        done < <(find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -printf '%T@ %p\n' | sort -n | tee "$DACTI_APPS_CACHE_FILE")
    fi
    exec 3<&-
}

__dacti_update_categories()
{
    declare \
            cats= \
            file= \
            i=

    declare -a \
               categories=() \
               main=() \
               sub=()

    cd -- "$DACTI_CATS_DATA_DIR" || return 1

    while IFS=':' read -r file cats
    do
        cats=${cats#Categories=}
        categories=(${cats//;/ })

        ((${#categories[@]} == 0)) && continue

        mapfile -t main < <(find . -mindepth 1 -maxdepth 1 -type d -print | fgrep -e "$(printf '%s\n' ${categories[@]})")
        mapfile -t sub < <(__dacti_comm_array "${categories[@]}" -- "${main[@]#./}")

        for i in "${sub[@]}"
        do
            grep -q "^${i}\>" "$DACTI_CATS_SUB_INFO_FILE" || unset -v "sub[$i]"
        done

        if ((${#sub[@]} > 0))
        then
            while IFS= read -rd ''
            do
                ln -f -s "$file" "$REPLY"
            done < <(find ${main[*]} -mindepth 1 -type d -print0 | grep -zZ -f <(printf '%s$\n' ${sub[@]}))
        else
            for i in "${main[@]}"
            do
                ln -f -s "$file" "$i"
            done
        fi
    done < <(find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -exec grep -HR '^Categories' /dev/null {} + | tee "$DACTI_CATS_INDEX_FILE")
}

__dacti_update_keywords()
{
    declare \
            file= \
            keywords=

    while IFS=':' read -r file keywords
    do
        keywords=${keywords#Keywords=}
        while read -r -d ';'
        do
            printf '%s\n' "$REPLY"
        done <<< "$keywords"
    done < <(find ${xdg_applications[*]} $xdg_applications_home -name '*.desktop' -exec grep -HR '^Keywords=' /dev/null {} + | sed -e '{s/ $//;s/$/;/;s/;;/;/;s/; /;/g}' | tee "$DACTI_KEYWS_INDEX_FILE") | sort | uniq 1> "$DACTI_KEYWS_CACHE_FILE"
}

__dacti_set_args()
{
    builtin declare o=
    if [[ ! $OPTARG =~ ^-.+ ]]
    then
        for o
        do
            builtin declare -g "$o"
        done
    else
        { builtin printf '%s\n' "Option -${opt} requires an argument." 1>&2 ; builtin exit 1 ; }
    fi
}

__dacti_status_code()
{
    declare \
            status_code=$1 \
            status_message=$2

    if (($status_code == 0))
    then
        printf '%s\n' "$(date +%Y-%m-%d_%H:%M:%N) success ${status_message}" 1>> "$DACTI_LOG_FILE"
    else
        printf '%s\n' "${0##*/}:Status:Error:${status_code}: ${status_message}" 1>&2
        printf '%s\n' "$(date +%Y-%m-%d_%H:%M:%N) error ${status_message}" 1>> "$DACTI_LOG_FILE"
    fi

    exit "$status_code"
}

__dacti_logger()
{
    declare log_message=$1

    printf '%s\n' "$(date +%Y-%m-%d_%H:%M:%N) event ${log_message}" 1>> "$DACTI_LOG_FILE"
}

# -- MAIN.


__dacti_main()
{
    # Prepare performing options from command line.
    builtin declare \
        arg= \
        args= \
        delim=\'

    # Translate long options into short options.
    for arg
    do
        arg=${arg#--}
        case $arg in
            conf-file=?*)           args="${args}-C ${delim}${arg#*=}${delim} " ;;
            help)                   args="${args}-h "                           ;;
            pretend)                args="${args}-p "                           ;;
            quit)                   args="${args}-q "                           ;;
            update-applications)    args="${args}-a "                           ;;
            update-categories)      args="${args}-c "                           ;;
            update-keywords)        args="${args}-k "                           ;;
            version)                args="${args}-v "                           ;;
            *)                      if [[ ${arg:0:1} == - ]]
                                    then
                                        args="${args}${arg} "
                                    else
                                        args="${args}${delim}${arg}${delim} "
                                    fi
        esac
    done

    builtin declare \
        opt= \
        pretend= \
        quit= \
        update_applications= \
        update_categories= \
        update_keywords=

    # Do getopts.
    builtin eval builtin set -- "$args"
    while builtin getopts :acC:hkpqv opt
    do
        case $opt in
            C)  __dacti_set_args "DACTI_CONF_FILE=$OPTARG"    ;;
            a)  update_applications=update_applications         ;;
            c)  update_categories=update_categories             ;;
            h)  __dacti_help ; builtin exit 0                   ;;
            k)  update_keywords=update_keywords                 ;;
            p)  pretend=pretend                                 ;;
            q)  quit=quit                                       ;;
            v)  __dacti_version ; builtin exit 0                ;;
            :)  builtin printf '%s\n' "Option '-${OPTARG}' requires an argument." 1>&2
                builtin exit 1                                  ;;
            \?) builtin printf '%s\n' "Unknown flag: '-${OPTARG}'." 1>&2
                builtin exit 1
        esac
    done
    builtin shift $((OPTIND-1))

    # Declare some enviroments, before we will source a Conf File.
    builtin declare \
        predir_datadir=${XDG_DATA_HOME:-${HOME}/.local/share} \
        predir_configdir=${XDG_CONFIG_HOME:-${HOME}/.config}
    builtin declare -gr DACTI_CONF_FILE=${DACTI_CONF_FILE:-${predir_configdir}/dacti}/dacti.conf
    builtin declare -gA d_color
    builtin declare -g \
        menu_0_prompt= \
        term=
    builtin declare -ga "menu_0=()"

    if [[ -f $DACTI_CONF_FILE ]]
    then
        builtin source "$DACTI_CONF_FILE" 2>/dev/null || \
        { builtin printf '%s\n' "${0##*/}:Status:Error:1: ${DACTI_CONF_FILE} has not been sourced." 1>&2 ; builtin exit 1 ; }
    else
         { builtin printf '%s\n' "${0##*/}:Status:Error:1: ${$DACTI_CONF_FILE} is not a regular file." 1>&2 ; builtin exit 1 ; }
    fi

    # Now declare all other enviroment variables.
    builtin declare -gr DACTI_DATA_DIR=${DACTI_DATA_DIR:-${predir_datadir}/dacti}
    builtin declare -gr \
       DACTI_APPS_INDEX_FILE=${DACTI_APPS_INDEX_FILE:-${DACTI_DATA_DIR}/dacti_applications.index} \
       DACTI_APPS_CACHE_FILE=${DACTI_APPS_CACHE_FILE:-${DACTI_DATA_DIR}/dacti_applications.cache} \
       DACTI_CATS_DATA_DIR=${DACTI_CATS_DATA_DIR:-${DACTI_DATA_DIR}/Categories} \
       DACTI_CATS_INDEX_FILE=${DACTI_CATS_INDEX_FILE:-${DACTI_DATA_DIR}/dacti_categories.index} \
       DACTI_CATS_MAIN_INFO_FILE=${DACTI_CATS_MAIN_INFO_FILE:-${DACTI_DATA_DIR}/dacti_categories_main.info} \
       DACTI_CATS_SUB_INFO_FILE=${DACTI_CATS_SUB_INFO_FILE:-${DACTI_DATA_DIR}/dacti_categories_sub.info} \
       DACTI_KEYWS_INDEX_FILE=${DACTI_KEYWS_INDEX_FILE:-${DACTI_DATA_DIR}/dacti_keywords.index} \
       DACTI_KEYWS_CACHE_FILE=${DACTI_KEYWS_CACHE_FILE:-${DACTI_DATA_DIR}/dacti_keywords.cache} \
       DACTI_LOG_FILE=${DACTI_LOG_FILE:-${DACTI_DATA_DIR}/dacti.log} \
       DACTI_TMP_DIR=${DACTI_TMP_DIR:-${TMPDIR:-/tmp}} \
       xdg_data_dirs=${XDG_DATA_DIRS:-/usr/local/share:/usr/share}
    builtin declare -gr \
        DACTI_APPS_DIRS=${DACTI_APPS_DIRS:-${xdg_data_dirs}} \
        DACTI_APPS_DIR_HOME=${DACTI_APPS_DIR_HOME:-${predir_datadir}/applications}
    builtin declare -gr xdg_applications_home=$DACTI_APPS_DIR_HOME
    builtin declare -a "xdg_applications=(${DACTI_APPS_DIRS//:/ })"
    builtin declare -gra "xdg_applications=(${xdg_applications[@]/%/\/applications})"
    builtin declare -gr \
        menu_0_prompt=${menu_0_prompt:->} \
        term=${term:-xterm}
    builtin declare -gra "menu_0=(${menu_0[@]:-BIN-ASC BIN-ATIME-ASC BIN-ATIME-DESC BIN-DESC CATEGORIES KEYWORDS LOG OCCUR})"
    builtin declare -g invocation_mode=

    if command tty -s
    then
        invocation_mode=cli
    elif [[ $DISPLAY ]]
    then
        invocation_mode=gui
    else
        { builtin printf '%s\n' "${0##*/}:Status:Error:1: Neither cli nor gui mode." 1>&2 ; builtin exit 1 ; }
    fi

    # Create index file and app dir, if they have not been created before.
    [[ -d $DACTI_DATA_DIR ]] || command mkdir -p "$DACTI_DATA_DIR"
    [[ -f $DACTI_APPS_INDEX_FILE ]] || 1> "$DACTI_APPS_INDEX_FILE"

    # Perform options from command line.
    [[ $update_applications == update_applications ]] && __dacti_update_applications
    [[ $update_categories == update_categories ]] && __dacti_update_categories
    [[ $update_keywords == update_keywords ]] && __dacti_update_keywords
    [[ $quit == quit ]] && __dacti_status_code 0 "Quit: With these command line options: ${index_applications:+${index_applications/%/ }}${update_categories:+${update_categories/%/ }}${update_keywords}."

    # Unset variables and functions, we do not need anymore.
    builtin unset -v \
        arg \
        args \
        delim \
        opt \
        predir_configdir
        predir_datadir \
        quit \
        update_applications \
        update_categories \
        update_keywords
    builtin unset -f __dacti_set_args

    # Perform the main selection menu and handle selections.
    builtin declare -g selection=
    while builtin :
    do
        selection=$(__dacti_selection_0 | __dacti_menu_cmd)
        case ${selection,,} in
            \[bin-asc\])
                __dacti_check_status "$(__dacti_bin_asc | __dacti_menu_cmd "BIN-ASC")"
                ;;
            \[bin-atime-asc\])
                __dacti_check_status "$(__dacti_bin_atime_asc | __dacti_menu_cmd "BIN-ATIME-ASC")"
                ;;
            \[bin-atime-desc\])
                __dacti_check_status "$(__dacti_bin_atime_desc | __dacti_menu_cmd "BIN-ATIME-DESC")"
                ;;
            \[bin-desc\])
                __dacti_check_status "$(__dacti_bin_desc | __dacti_menu_cmd "BIN-DESC")"
                ;;
            *\[categories\])
                __dacti_browse_categories "$selection"
                ;;
            *\[keywords\])
                __dacti_browse_keywords "$selection"
                ;;
            \[log\])
                selection=$(__dacti_browse_log | __dacti_menu_cmd "LOG") && \
                [[ $selection =~ (^.* launch .*$) ]] && \
                __dacti_check_status "${selection#* * }" || \
                builtin continue
                ;;
            \[occur\])
                selection=$(__dacti_occur | __dacti_menu_cmd "OCCUR") && \
                __dacti_check_status "${selection#      * }"
                ;;
            \[*\])
                builtin declare -f __dacti_selection_custom 1>/dev/null 2>&1 && \
                __dacti_selection_custom "${selection//[\[\]]/}"
                ;;
            "")
                __dacti_status_code 0 "Quit: Nothing has been chosen."
                ;;
            *)
                __dacti_check_status "$selection"
        esac
    done
}

__dacti_main "$@"
